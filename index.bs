<pre class='metadata'>
Group: AOM
Status: WGD
Title: Immersive Audio Container
Editor: SungHee Hwang, Samsung, hshee@samsung.com
Editor: Felicia Lim, Google, flim@google.com
Repository: AOMediaCodec/iac
Shortname: iac
URL: https://aomediacodec.github.io/iac/
Date: 2022-09-19
Abstract: This document specifies the immersive audio (IA) bitstream format and the container format for the IA bitstream in one single [[!ISOBMFF]] track.
</pre>

<pre class="anchors">
url: https://www.iso.org/standard/68960.html#; spec: ISOBMFF; type: dfn;
	text: AudioSampleEntry
	text: boxtype
	text: grouping_type
	text: SampleGroupDescriptionEntry
	text: channelcount
	text: samplerate

url: https://www.iso.org/standard/68960.html#; spec: ISOBMFF; type: property;
	text: iso6
	text: sgpd
	text: stsd
	text: sbgp

url: https://www.iso.org/standard/43345.html#; spec: AAC; type: dfn;
	text: raw_data_block()
	text: ADTS
	text: Low Complexity Profile

url: https://opus-codec.org/docs/opus_in_isobmff.html#; spec: OPUS-IN-ISOBMFF; type: dfn;
	text: OpusSpecificBox
	text: OutputChannelCount
	text: OutputGain
	text: ChannelMappingFamily
	text: PreSkip
	text: InputSampleRate


url: https://opus-codec.org/docs/opus_in_isobmff.html#; spec: OPUS-IN-ISOBMFF; type: property;
	text: opus
	text: dOps

url: https://www.iso.org/standard/55688.html#; spec: MP4-Systems; type: dfn;
	text: objectTypeIndication
	text: streamType
	text: upstream
	text: decSpecificInfo()
	text: DecoderConfigDescriptor()

url: https://www.iso.org/standard/76383.html#; spec: MP4-Audio; type: dfn;
	text: AudioSpecificConfig()
	text: audioObjectType
	text: channelConfiguration
	text: GASpecificConfig()
	text: frameLengthFlag
	text: dependsOnCoreCoder
	text: extensionFlag

url: https://www.iso.org/standard/79110.html#; spec: MP4; type: dfn;
	text: ESDBox

url: https://www.iso.org/standard/79110.html#; spec: MP4; type: property;
	text: mp4a
	text: esds

url: https://tools.ietf.org/html/rfc6381#; spec: RFC6381; type: property;
	text: codecs

url: https://tools.ietf.org/html/rfc8486#; spec: RFC8486; type: dfn;
	text: channel count

url: https://tools.ietf.org/html/rfc7845#; spec: RFC7845; type: dfn;
	text: ID Header
	text: Output Gain

url: https://tools.ietf.org/html/rfc6716#; spec: RFC6716; type: dfn;
	text: opus packet

url: https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.1770-4-201510-I!!PDF-E.pdf#; spec: ITU1770-4; type: dfn;
	text: LKFS

url: https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.2051-3-202205-I!!PDF-E.pdf#; spec: ITU2051-3; type: dfn;
	text: Loudspeaker configuration for Sound System A (0+2+0)
	text: Loudspeaker configuration for Sound System B (0+5+0)
	text: Loudspeaker configuration for Sound System C (2+5+0)
	text: Loudspeaker configuration for Sound System D (4+5+0)
	text: Loudspeaker configuration for Sound System I (0+7+0)
	text: Loudspeaker configuration for Sound System J (4+7+0)

url: https://en.wikipedia.org/wiki/Q_(number_format); spec: Q-Format; type: dfn;
	text:

url: https://xiph.org/flac/format.html; spec: FLAC; type: dfn;
	text: METADATA_BLOCK
	text: FRAME
	text: FRAME_HEADER
	text: SUBFRAME
	text: FRAME_FOOTER

url: https://xiph.org/flac/format.html; spec: FLAC; type: property;
	text: fLaC


</pre>

<pre class='biblio'>
{
	"AI-CAD-Mixing": {
		"title": "AI 3D immersive audio codec based on content-adaptive dynamic down-mixing and up-mixing framework",
		"status": "Paper",
		"publisher": "AES",
		"href": "https://www.aes.org/e-lib/browse.cfm?elib=21489"
	},
	"AAC": {
		"title": "Information technology — Generic coding of moving pictures and associated audio information — Part 7: Advanced Audio Coding (AAC)",
		"status": "Standard",
		"publisher": "ISO/IEC",
		"href": "https://www.iso.org/standard/43345.html"
	},
	"MP4-Audio": {
		"title": "Information technology — Coding of audio-visual objects — Part 3: Audio",
		"status": "Standard",
		"publisher": "ISO/IEC",
		"href": "https://www.iso.org/standard/76383.html"
	},
	"MP4-Systems": {
		"title": "Information technology — Coding of audio-visual objects — Part 1: Systems",
		"status": "Standard",
		"publisher": "ISO/IEC",
		"href": "https://www.iso.org/standard/55688.html"
	},
	"OPUS-IN-ISOBMFF": {
		"title": "Encapsulation of Opus in ISO Base Media File Format",
		"status": "Best Practice",
		"publisher": "IETF",
		"href": "https://opus-codec.org/docs/opus_in_isobmff.html"
	},
	"ITU1770-4": {
		"title": "Algorithms to measure audio programme loudness and true-peak audio level",
		"status": "Standard",
		"publisher": "ITU",
		"href": "https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.1770-4-201510-I!!PDF-E.pdf"
	},
	"ITU2051-3": {
		"title": "Advance sound system for programme production",
		"status": "Standard",
		"publisher": "ITU",
		"href": "https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.2051-3-202205-I!!PDF-E.pdf"
	},
	"Q-Format": {
		"title": "Q (number format)",
		"status": "Best Practice",
		"publisher": "Wikepedia",
		"href": "https://en.wikipedia.org/wiki/Q_(number_format)"
	},
	"FLAC": {
		"title": "Free Lossless Audio Codec",
		"status": "Best Practice",
		"publisher": "xiph.org",
		"href": "https://xiph.org/flac/format.html"
	}

}
</pre>


# Introduction # {#introduction}

The <dfn noexport>IA bitstream</dfn> is designed to represent immersive audio for presentation on a wide range of devices in both dynamic streaming and offline applications. These applications include internet audio streaming, multicasting/broadcasting services, file download, gaming, communication, virtual and augmented reality, and others. In these applications, audio may be played back on a wide range of devices, e.g. headsets, mobile phones, tablets, TVs, sound bars, home theater systems and big screen.

The bitstream comprises a number of coded audio substreams and the metadata that describes how to decode, render and mix the substreams to generate an audio signal for playback. The bitstream format itself is codec-agnostic; any supported audio codec may be used to code the audio substreams.

The immersive audio container (<dfn noexport>IAC</dfn>) is the storage format for immersive audio (IA) bitstream in one single [[!ISOBMFF]] track.

The figure below shows the conceptual IAC architecture.

<center><img src="images/Conceptual IAC Architecture.png"></center>
<center><figcaption>Conceptual IAC Architecture</figcaption></center>

For a given input 3D audio,
- Pre-Processor generates Pre-Processed Audio and Codec Agnostic Metadata for immersive audio (IA).
- Audio Codec Enc generates Codec-Dependent Bitstream, which consists of the coded streams, coded from Pre-Processed Audio.
- File Packager generates IAC File by encapsulating IA bitstream, which consists of Codec-Dependent Bitstream and Codec Agnostic Metadata, into [[!ISOBMFF]] tracks.
- File Parser reconstructs IA bitstream by decapsulating IAC File.
- Audio Codec Dec outputs a decoded Pre-Processed Audio after decoding of Codec-Dependent Bitstream.
- Post-Processor outputs Immersive 3D Audio by using the decoded Pre-Processed Audio and Codec Agnostic Metadata.


The rest of this specification is formulated as follows:
- [[#overview]] describes the high level IA bitstream architecture and introduces its components.
- [[#obu-syntax]] specifies the syntax and semantics of the top level IA components and detailed IA components.
- [[#profiles]] specifies the profiles for IA bitstreams and IA decoders.
- [[#standalone]] specifies the representation of a standalone IA bitstream.
- [[#isobmff]] specifies the encapsulation of an IA bitstreaminto [[!ISOBMFF]] tracks.
- [[#processing]] specifies how the IA bitstream should be decoded to generatethe output immersive 3D audio.
- [[#iac-generation]] provides a guideline for generating the IA bitstream.
- [[#iac-consumption]] provides a guideline for consuming the IA bitstream, for different use-cases.


# Overview # {#overview}

## IA Bitstream Components ## {#iab-components}

The IA bitstream includes one or more audio elements, each of which consists of one or more audio substreams. The IA bitstream further include mix presentations and parameters.

- <dfn noexport>Audio substream</dfn> is the actual audio signal, which may be encoded with any compatible audio codec.
- <dfn noexport>Audio element</dfn> is the 3D representation of the audio signals, and are constructed from one or more audio substreams and the metadata describing them. The audio substreams associated with one audio element use the same audio codec.
- <dfn noexport>Mix presentations</dfn> contain metadata that describe how the audio elements are rendered and mixed together for playback through physical loudspeakers or headphones. At any given time, only one mix presentation is used for playback. However, multiple mix presentations can be defined as alternatives to each other within the same IA bitstream. Furthermore, the choice of which mix presentation to use at playback is left to the user. For example, multi-language support is implemented by defining different mix presentations, where the first mix describes the use of the audio element with English dialogue, and the second mix describes the use of the audio element with French dialogue.
- <dfn noexport>Parameters</dfn> are the values that are associated with the algorithms used for decoding, reconstructing, rendering and mixing. Parameters may change their values over time and may further be animated; for example, any changes in values may be smoothed over some time interval. Their rate of change is specific to its respective algorithm, and is independent of other algorithms and the frame rates associated with the audio substreams. As such, they may be viewed as a 1D signal that have different metadata specified for different time intervals.


The figure below shows the relationship between the audio substreams, audio elements and mix presentations and the processing flow to obtain the immersive audio playback.

<center><img src="images/decoding_flow_cropped.png" style="width:100%; height:auto;"></center>
<center><figcaption>Processing flow to decode, reconstruct, render and mix the audio signals for immersive audio playback.</figcaption></center>

## Use of OBU Syntax ## {#use-of-obu}

ISSUE: This section introduces OBUs and their purpose. Needs some cleanup.

### Descriptors

The descriptor OBUS shall contain all the information that is required to setup and configure the decoders, reconstruction algorithms, renderers and mixers.

- <dfn noexport>Start Code OBU</dfn> indicates the start of a full IA bitstream description, version and profile version.
- <dfn noexport>Codec Config OBU</dfn> describes information to set up a decoder for an audio substream.
- <dfn noexport>Audio Element OBU</dfn> describes information to combine one or more audio substreams to reconstruct an audio element.
- <dfn noexport>Mix Presentation OBU</dfn> describes information to render and mix one or more audio elements to generate the final audio output.

### Data

The data OBUs contain the actual time-varying data that is required in the generation of the final audio output.

- <dfn noexport>Parameter Block OBU</dfn> provides the time-varying parameter values for an algorithm used in any of the decoding, reconstruction, rendering or mixing steps.
- <dfn noexport>Audio Frame OBU</dfn> provides the raw coded audio frame for an audio substream.

### Logistics

The IA bitstream supports the description of multiple audio substreams and algorithms, which may have different metadata update rates to each other. The update rate for the audio substreams and audio elements is governed by the frame rates of the audio codec used. Since a single bitstream may support multiple codecs, this may lead to multiple different frame rates. The algorithms for rendering and mixing may have parameters that update at different rates to each other and to the audio frame rates.

Therefore, the IA bitstream contains information to facilitate the synchronization of the different IA metadata. The synchronizing information in each metadata indicates the offset from a reference point and the duration for which it is valid.

- <dfn noexport>Sync OBU</dfn> defines reference points in the bitstream, which used to synchronize the data OBUs with each other.


# Open Bitstream Unit (OBU) Syntax and Semantics # {#obu-syntax}

## Top Level OBU Syntax and Semantics ## {#top-level-syntax}

The IA bitstream uses the OBU syntax. This section specifies the top-level OBU syntax elements and their semantics.

### Audio OBU Syntax and Semantics ### {#audio-obu}

<b>Syntax</b>

```
class audio_open_bitstream_unit() {
  obu_header();

  if (obu_type == OBU_IA_Start_Code)
    start_code_obu();
  else if (obu_type == OBU_IA_Codec_Config)
    codec_config_obu();
  else if (obu_type == OBU_IA_Audio_Element)
    audio_element_obu();
  else if (obu_type == OBU_IA_Mix_Presentation)
    mix_presentation_obu();
  else if (obu_type == OBU_IA_Parameter_Block)
    parameter_block_obu();
  else if (obu_type == OBU_IA_Audio_Frame)
    audio_frame_obu();
  else if (obu_type == OBU_IA_Sync)
    sync_obu();
  else
    reserved_obu()

  byte_alignment():
}
```

<b>Semantics</b>

If the syntax element obu_type is equal to OBU_IA_Start_Code, an ordered series of OBUs is presented to the decoding process as a string of bytes.

OBU data shall start on the first (most significant) bit and shall end on the last bit of the given bytes. The payload of an OBU shall lie between the first bit of the given bytes and the last bit before the first zero bit of the byte_alignment() function call.


### OBU Header Syntax and Semantics ### {#obu-header}

<b>Syntax</b>

```
class obu_header() {
  unsigned int (4) obu_type;
  unsigned int (1) obu_id_flag;
  unsigned int (1) obu_sync_flag;
  unsigned int (1) obu_duration_flag;
  unsigned int (1) obu_counter_flag;
  unsigned int (1) obu_extension_flag;
  unsigned int (7) obu_reserved_7bit;

  unsigned int (leb128()) obu_size;

  if (obu_id_flag == 1)
    unsigned int (leb128()) obu_id;
  if (obu_sync_flag == 1)
    unsigned int (leb128()) obu_sync;
  if (obu_duration_flag == 1)
    unsigned int (leb128()) obu_duration;
  if (obu_counter_flag == 1)
    unsigned int (leb128()) obu_counter;
  if (obu_extension_flag == 1)
    unsigned int (leb128()) extension_header_size;
}
```

<b>Semantics</b>

OBUs are structured with a header and a payload.

<dfn noexport>obu_type</dfn> shall specify the type of data structure contained in the OBU payload.

<pre class = "def">
obu_type: Name of obu_type
   0    : Reserved
   1    : OBU_IA_Codec_Config
   2    : OBU_IA_Audio_Element
   3    : OBU_IA_Mix_Presentation
   4    : OBU_IA_Parameter_Block
   5    : OBU_IA_Audio_Frame
   6    : OBU_IA_Sync
  7~14  : Reserved
   15   : OBU_IA_Start_Code
</pre>

<dfn noexport>obu_size</dfn> shall indicate the size in bytes of the OBU not including the bytes within obu_header of the preceding fields, i.e. obu_type, the various OBU flags and obu_reserved_7bit.

<dfn noexport>obu_id</dfn> shall indicate a unique ID according to the obu_type.
 - If obu_type = OBU_IA_Audio_Element, then it shall indicate a unique ID (i.e. audio_element_id) for a given audio element in IA sequence.
 - If obu_type = OBU_IA_Mix_Presentation, then it shall indicate a unique ID (i.e. mix_presentation_id) for a given mix presentation in IA sequence.
 - If obu_type = OBU_IA_Parameter_Block, then it shall indicate a unique ID (i.e. parameter_id) for a given parameter in IA sequence.
 - If obu_type = OBU_IA_Audio_Frame, then it shall indicate a unique ID (i.e. audio_substream_id) for a given substream in IA sequence. Therefore, all of audio_frame_obus of the same substream shall have the same obu_id.


<dfn noexport>obu_sync</dfn> shall define the offset from a reference point in the IA bitstream for which the OBU is valid and applicable. The reference point used depends on the IA Profile (See Profiles Section).

<dfn noexport>obu_duration</dfn> shall define the duration for which the OBU is valid and applicable.

<dfn noexport>obu_counter</dfn> shall increment when its payload is different to the previous OBU of the same obu_type. If the payload is identical to the previous OBU of the same obu_type, i.e. it was redundantly copied or repeated in the bitstream, the value of obu_counter shall remain unchanged.

<dfn noexport>extension_header_size</dfn> shall indicate the size in bytes of the extension.

<dfn noexport>obu_reserved_7bit</dfn> shall be set to 0. Reserved units are for future use and shall be ignored by an IAC-OBU parser.

### Byte Alignment Syntax and Semantics ### {#obu-bytealignment}

<b>Syntax</b>

```
class byte_alignment() {
  while (get_position() & 7)
    unsigned int (1) zero_bit;
}
```

<b>Semantics</b>

<dfn noexport>zero_bit</dfn> shall be equal to 0 and shall be inserted into the bitstream to align the bit position to a multiple of 8 bits.


### Reserved OBU Syntax and Semantics ### {#obu-reserved}

The reserved OBU allows the extension of this specification with additional OBU types in a way that allows IAC-OBU parsers compliant to this version of specification to ignore them.


### Start Code OBU Syntax and Semantics ### {#obu-startcode}

This section shall specify obu payload of OBU_IA_Start_Code.

For this obu, the obu header (3 bytes) shall be set to 0xF07F02.

<b>Syntax</b>

```
class start_code_obu() {
  unsigned int (16) ia_code;
  unsigned int (8) version;
  unsigned in t(8) profile_version
}
```

<b>Semantics</b>

<dfn noexport>ia_code</dfn> shall be a ‘two-character code’ (2CC) to identify the start of the IA bitstream. It shall be 'ia'.

<dfn noexport>version</dfn> shall indicate the version of an IA sequence. It shall be set to 0 for this version of the specification. Implementations should treat IA bitstreams where the MSB four bits of the version number match that of a recognized specification as backwards compatible with that specification. That is, the version number can be split into "major" and "minor" version sub-fields, with changes to the minor sub-field (in the LSB four bits) signaling compatible changes. For example, an implementation of this specification should accept any stream with a version number of ’15’ or less, and should assume any stream with a version number ’16’ or
greater is incompatible.

<dfn noexport>profile_version</dfn> shall indicate the profile of an IA sequence. The MSB four bits shall indicate the profile of an IA sequence. Implementations should treat IA bitstreams where the MSB four bits of the version number match that of a recognized profile as backwards compatible with that specification. That is, the version number can be split into "profile major" and "profile minor" version sub-fields, with changes to the minor sub-field (in the LSB four bits) signaling compatible changes with the profile major version. The semantic of this field shall be only valid when the MSB four bits of [=version=] = 0.

### Codec Config OBU Syntax and Semantics ### {#obu-codecconfig}

This section shall specify obu payload of OBU_IA_Codec_Config.

For this obu, all of obu_id_flag, obu_sync_flag and obu_duratrion_flag shall be set to 0.


<b>Syntax</b>

```
class codec_config_obu() {
  f(1) substream_id_mode;
  unsigned int (7) reserved;

  if (substream_id_mode == ALL) {
    codec_config();
  } else if (substream_id_mode == MANY) {
    unsigned int (leb128()) num_substreams;
    for (i = 0; i < num_substreams; i++) {
      unsigned int (leb128()) audio_substream_id;
      codec_config();
    }
  }
}

class <dfn noexport>codec_config()</dfn> {
  unsigned int (32) codec_id;
  decoder_config(codec_id);
  unsigned int (leb128()) num_samples_per_frame;
  unsigned int (leb128()) num_samples_to_trim_at_start;
  unsigned int (leb128()) num_samples_to_trim_at_end;
}
```

<b>Semantics</b>

<dfn noexport>substream_id_mode</dfn> shall specify the method used for signalling the metadata for the audio substreams.

<pre class = "def">
substream_id_mode: Method for signalling the metadata for the audio substreams.
   0    : ALL
   1    : MANY
</pre>

If substream_id_mode is equal to ALL, this indicates that all substreams shall be configured identically. Only one set of configuration shall need to be specified, provided by codec_config().

If substream_id_mode is equal to MANY, this indicates that all substreams may be configured differently. Each substream shall requires a corresponding set of configuration to be specified, provided by codec_config() per audio_substream_id.

<dfn noexport>audio_substream_id</dfn> shall be a unique ID for a given substream in an IA sequence. All of audio_frame_obus of the substream shall have this audio_substream_id.

<dfn noexport>codec_id</dfn> shall be a ‘four-character code’ (4CC) to identify the codec used to generate the audio substreams. It shall be 'opus' for IAC-OPUS, 'mp4a' for IAC-AAC-LC, 'fLaC' for IAC-FLAC and 'lpcm' for IAC-LPCM.

For ISOBMFF encapsulation, it shall be the same as the [=boxtype=] of its AduioSampleEntry if exist. 

<dfn noexport>decoder_config()</dfn> specifies the set of codec parameters required to decode an audio substream for the given codec_id.
- The codec_id and decoder_config() for IAC-OPUS shall conform to [=Codec_Specific_Info=] of [[#iac-opus-specific]]
- The codec_id and decoder_config() for IAC-AAC-LC shall conform to [=Codec_Specific_Info=] of [[#iac-aac-lc-specific]].
- The codec_id and decoder_config() for IAC-FLAC shall conform to [=Codec_Specific_Info=] of [[#iac-flac-specific]]
- The codec_id and decoder_config() for IAC-LPCM shall conform to [=Codec_Specific_Info=] of [[#iac-lpcm-specific]].

<dfn noexport>num_samples_per_frame</dfn> shall indicate the frame length, in samples, of the raw coded audio provided in by audio_frame_obu().

<dfn noexport>num_samples_to_trim_at_start</dfn> shall indicate the number of samples that needs to be trimmed from the start of the audio substream for gapless playback. It shall be same as that in decoder_config() if any or that implied from information of decoder_config() and its substream format.

<dfn noexport>num_samples_to_trim_at_end</dfn> shall indicate the number of samples that needs to be trimmed from the end of the audio substream for gapless playback. It shall be same as that in decoder_config() if any. It shall be same as that in decoder_config() if any or that implied from information of decoder_config() and its substream format.


### Audio Element OBU Syntax and Semantics ### {#obu-audioelement}

This section shall specify obu payload of OBU_IA_Audio_Element.

For this obu, both of obu_sync_flag and obu_duratrion_flag shall be set to 0.


<b>Syntax</b>

```
class audio_element_obu() {
  f(3) audio_element_type;
  unsigned int (5) reserved;

  unsigned int (leb128()) num_substreams;
  for (i = 0; i < num_substreams; i++) {
    unsigned int (leb128()) audio_substream_id_ref;
  }

  if (audio_element_type == CHANNEL_BASED) {
    scalable_channel_layout_config();
  } else if (audio_element_type == SCENE_BASED) {
    ambisonics_config();
  }
}
```

<b>Semantics</b>

<dfn noexport>audio_element_type</dfn> shall specify the audio representation of this audio element which is constructed from one or more audio substreams.

<pre class = "def">
audio_element_type: The type of audio representation.
   0    : CHANNEL_BASED
   1    : SCENE_BASED
  2~7   : Reserved
</pre>

<dfn noexport>num_substreams</dfn> shall specify the number of audio substreams that are used to reconstruct this audio element.

<dfn value noexport for="audio_element">audio_substream_id_ref</dfn> shall specify the unique ID of the audio substream that is used to reconstruct this audio element.

<dfn noexport>scalable_channel_layout_config()</dfn> is a function call that provides the metadata required for combining the substreams identified here in order to reconstruct a scalable channel layout.

<dfn noexport>ambisonics_config()</dfn> is a function call that provides the metadata required for combining the substreams identified here in order to reconstruct an Ambisonics layout.


### Mix Presentation OBU Syntax and Semantics ### {#obu-mixpresentation}

This section shall specify obu payload of OBU_IA_Mix_Presentation.

For this obu, both of obu_sync_flag and obu_duratrion_flag shall be set to 0.

The metadata in mix_presentation() shall specify how to render and process one or more audio elements. The processed audio elements shall then be summed to generate a single mixed audio signal. Finally, any additional processing specified in the mix_bus_config() metadata shall be applied to the single mixed audio signal in order to generate the final output audio for playback.


<b>Syntax</b>
```
class mix_presentation_obu() {
  string mix_presentation_friendly_label;
  unsigned int (4) mix_target_layout;
  unsigned int (4) reserved;

  unsigned int (leb128()) num_audio_elements;
  for (i = 0; i < num_audio_elements; i++) {
    string audio_element_friendly_label;
    unsigned int (leb128()) audio_element_id_ref;
    rendering_config();
    element_mix_config();
  }

  mix_bus_config();
  mix_loudness_info();
}
```


<b>Semantics</b>

<dfn noexport>mix_presentation_friendly_label</dfn> shall specify a human-friendly label to describe this mix presentation.

ISSUE: Which format is used for the string?

<dfn noexport>mix_target_layout</dfn> shall specify the target playback layout that all referenced audio elements shall be rendered for. 

<pre class = "def">
Mix Target Layout (4 bits) :  Channel Layout  : Loudspeaker Location Ordering
            0000           :       Mono       : C
            0001           :      Stereo      : L/R
            0010           :      5.1ch       : L/C/R/Ls/Rs/LFE
            0011           :     5.1.2ch      : L/C/R/Ls/Rs/Ltf/Rtf/LFE
            0100           :     5.1.4ch      : L/C/R/Ls/Rs/Ltf/Rtf/Ltr/Rtr/LFE
            0101           :      7.1ch       : L/C/R/Lss/Rss/Lrs/Rrs/LFE
            0110           :     7.1.2ch      : L/C/R/Lss/Rss/Lrs/Rrs/Ltf/Rtf/LFE
            0111           :     7.1.4ch      : L/C/R/Lss/Rss/Lrs/Rrs/Ltf/Rtf/Ltb/Rtb/LFE
            1000           :     3.1.2ch      : L/C/R//Ltf/Rtf/LFE
           others          :     reserved     :
</pre>

```
Where, C: Center, L: Left, R: Right, Ls: Left Surround, Lss: Left Side Surround, Rs: Right Surround, Rss: Right Side Surround, 
Ltf: Left Top Front, Rtf: Right Top Front, Ltr: Left Top Rear, Rtr: Right Top Rear, 
Ltb: Left Top Back, Rtb: Right Top Back, LFE: Low-Frequency Effects
```

An IA bitstream may have one or more mix_presentation() specified, each with different mix_target_layout values. In this case, the IA decoder shall select the mix presentation that matches the physical playback layout. If there is no match, the IA decoder shall select the closest specified layout and apply up or down-mixing appropriately. Sections [[#iaencoding-iaencoder-channelaudio-downmixmechanism]] and [[#iaencoding-downmixmatrix]] provide example dynamic and static down-mixing matrices for some common layouts that may be used by the IA decoder.

<dfn value noexport for="mix_presentation">num_audio_elements</dfn> shall specify the number of audio elements that are used in this mix presentation to generate the final output audio signal for playback.

<dfn noexport>audio_element_friendly_label</dfn> shall specify a human-friendly label to describe the referenced audio element.

ISSUE: Which format do you assume for the string?

<dfn noexport>audio_element_id_ref</dfn> shall specify the unique ID of the audio element that is used in this mix presentation.

<dfn noexport>rendering_config()</dfn> is the function call that provides the metadata required for rendering the referenced audio element.

<dfn noexport>element_mix_config()</dfn> is the function call that provides the metadata required for applying any processing to the referenced and rendered audio element before being summed with other processed audio elements.

<dfn noexport>mix_bus_config()</dfn> is the function call that provides the metadata required for applying any post-processing to the mixed audio signal to generate the final output audio signal for playback.

<dfn noexport>mix_loudness_info()</dfn> is the function call that provides the loudness information and statistics for the final output audio signal.


### Parameter Block OBU Syntax and Semantics ### {#obu-parameterblock}

This section shall specify obu payload of OBU_IA_Parameter_Block.

The metadata specified in this OBU shall define the parameters for an algorithm for an indicated duration, including any animation of the parameter values over this duration.

<b>Syntax</b>

```
class parameter_block_obu() {
  unsigned int (leb128()) parameter_type;

  if (parameter_type == CONSTANT) {
  }

  if (parameter_type == STEP) {
    unsigned int (leb128()) parameter_sample_rate;
  }

  if (parameter_type == LINEAR or EXPONENTIAL) {
    unsigned int (leb128()) parameter_sample_rate;
    unsigned int (leb128()) smoothing_duration;
  }

  if (parameter_type == PROCEDURAL) {
  }

  param_config(obu_id);
}
```

<b>Semantics</b>

<dfn noexport>parameter_type</dfn> shall specify the type of parameter.

<pre class = "def">
parameter_type : Parameter type.
       0       : CONSTANT
       1       : STEP
       2       : LINEAR
       3       : EXPONENTIAL
       4       : PROCEDURAL
</pre>

If parameter_type is equal to CONSTANT, this shall indicate that a single parameter value will be provided, and is intended to be applied to the audio samples.

If parameter_type is equal to STEP, LINEAR or EXPONENTIAL, this shall indicate that a series of parameter values will be provided as a 1D signal, and are intended to be applied to the audio samples. The rate at which these values are provided does not need to match the audio sample rate.
 - If parameter_type is equal to STEP, the parameters shall be applied immediately with no smoothing from the previous parameter values.
 - If parameter_type is equal to LINEAR, the parameter values shall be linearly interpolated from the previous parameter values over a duration specified by smoothing_duration.
 - If parameter_type is equal to EXPONENTIAL, the parameter values shall be interpolated from the previous parameter values following an exponentially decaying curve over a duration specified by smoothing_duration.

If parameter_type is equal to PROCEDURAL, this shall indicate that the parameter values provided are intended to parameterize some function, which also governs how the resulting values are applied to the audio samples.

<dfn noexport>parameter_sample_rate</dfn> shall specify the rate at which the parameters are provided. This value may be different from the audio sample rate.

<dfn noexport>smoothing_duration</dfn> shall specify the duration over which the parameter is interpolated from its previous value.

<dfn noexport>param_config()</dfn> is the function call that provides the actual parameter values and any additional metadata that may be required by the algorithm to specify how the parameter values are applied to the audio samples. This will be different for each algorithm.

### Audio Frame OBU Syntax and Semantics ### {#obu-audioframe}

This section shall specify obu payload of OBU_IA_Audio_Frame.

For this obu, both of obu_duratrion_flag and obu_counter_flag shall be set to 0.

<b>Syntax</b>

```
class audio_frame_obu(obu_size) {
  unsigned int (obu_size) substream();
}
```

<b>Semantics</b>

<dfn noexport>substream()</dfn> is a function call that contains the raw coded audio data.

### Sync OBU Syntax and Semantics ### {#obu-sync}

This section shall specify obu payload of OBU_IA_Sync.

For this obu, obu_sync_flag shall be set to 1 and all of obu_id_flag, obu_duratrion_flag and obu_counter_flag shall be set to 0.
 - obu_sync shall indicate the sync_offset from a reference point in the IA bitstream.

<b>Syntax</b>

```
class sync_obu() {
}
```

NOTE: sync_obu() has the empty payload

## Detailed OBU Syntax and Semantics ## {#syntax-detailed}

### Scalable Channel Layout Config Syntax and Semantics ### {#syntax-scalable-channel-layout-config}

[=scalable_channel_layout_config()=] shall contain information regarding the configuration of scalable channel audio.

<b>Syntax</b>

```
class scalable_channel_layout_config() {
  unsigned int (leb128()) num_parameters;
  for (i = 0; i < num_parameters; i++) {
    unsigned int (leb128()) parameter_id;
    unsigned int (leb128()) parameter_name;
  }

  unsigned int (3) num_layers;
  unsigned int (5) reserved;
  for (i = 1; i <= num_layers; i++) {
    channel_audio_layer_config(i);
  }
}

class channel_audio_layer_config(i) {
  unsigned int (4) loudspeaker_layout(i);
  unsigned int (1) output_gain_is_present_flag(i);
  unsigned int (1) recon_gain_is_present_flag(i);
  unsigned int (2) reserved;
  unsigned int (8) substream_count(i);
  unsigned int (8) coupled_substream_count(i);
  signed int (16) loudness(i);
  if (output_gain_is_present_flag(i) == 1) {
    unsigned int (6) output_gain_flag(i);
    unsigned int (2) reserved;
    signed int (16) output_gain(i);
  }
}
```

When an audio element is composed of G(r) number of substreams, scalable channel audio for the audio element shall be layered into [=num_layers=] = r number of ChannelGroups.
- <dfn noexport>ChannelGroup</dfn> shall be a set of substreams which is able to provide a spatial resolution of audio contents by itself or which is able to provide an enhanced spatial resolution of audio contents by combining with the preceding ChannelGroups within the [=audio frames=].
- ChannelGroup #q consists of G(q)-G(q-1) number of substreams. Where, q = 1, 2, ..., r and G(0) = 0.
- Audio Frames shall be a set of audio_frame_obus with the same sync offsets of the single audio element for scalable channel audio. Each of them comes from each substream.
- Every Audio Frames shall have the same number of audio_frame_obus.
- When r > 1, parameter_block_obu may present in front of every Audio Frames. 

<center><img src="images/Immersive Audio Bitstream with scalable channel audio (before OBU packing).png" style="width:100%; height:auto;"></center>
<center><figcaption>Immersive Audio Bitstream with scalable channel audio (before OBU packing)</figcaption></center>

<b>Semantics</b>

<dfn value noexport for="scalable_channel_layout_config">num_parameters</dfn> shall specify the number of parameters that are used by the algorithms specified in this audio element.

<dfn value noexport for="scalable_channel_layout_config">parameter_id</dfn> shall be a unique ID for a given parameter in IA sequence. It shall be same as obu_id of parameter_block_obu for the parameter_name in this config.

<dfn value noexport for="scalable_channel_layout_config">parameter_name</dfn> shall specify the name of the parameter.

<pre class = "def">
parameter_name : Parameter name.
       0       : SCALABLE_CHANNEL_LAYOUT_DEMIXING_INFO
       1       : SCALABLE_CHANNEL_LAYOUT_RECON_GAIN_INFO
</pre>

<dfn noexport>num_layers</dfn> shall indicate the number of ChannelGroups for scalable channel audio. It shall not be set to zero and its maximum number shall be limited to 6.

<dfn noexport>channel_audio_layer_config()</dfn> is a function call that provides the information regarding the configuration of ChannelGroup for scalable channel audio.

<dfn noexport>loudspeaker_layout</dfn> shall indicate the channel layout for the channels to be reconstructed from the precedent ChannelGroups and the current ChannelGroup among ChannelGroups for scalable channel audio.

In the current version of the specification, [=loudspeaker_layout=] shall indicate one of 9 channel layouts including Mono, Stereo, 5.1ch, 5.1.2ch, 5.1.4ch, 7.1ch, 7.1.2ch, 7.1.4ch and 3.1.2ch. Where,
- <dfn noexport>Stereo</dfn> is the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System A (0+2+0)=] of [[!ITU2051-3]].
- <dfn noexport>5.1ch</dfn> is the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System B (0+5+0)=] of [[!ITU2051-3]].
- <dfn noexport>5.1.2ch</dfn> is the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System C (2+5+0)=] of [[!ITU2051-3]].
- <dfn noexport>5.1.4ch</dfn> is the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System D (4+5+0)=] of [[!ITU2051-3]].
- <dfn noexport>7.1ch</dfn> is the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System I (0+7+0)=] of [[!ITU2051-3]].
- <dfn noexport>7.1.2ch</dfn> is the combination of the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System I (0+7+0)=] of [[!ITU2051-3]] and the left and right top front pair of the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System J (4+7+0)=] of [[!ITU2051-3]].
- <dfn noexport>7.1.4ch</dfn> is the loudspeaker configuration as depicted in [=Loudspeaker configuration for Sound System J (4+7+0)=] of [[!ITU2051-3]].
- <dfn noexport>3.1.2ch</dfn> is the front subset (L/C/R/Ltf/Rtf/LFE) of [=7.1.4ch=].

<pre class = "def">
Loudspeaker Layout (4 bits) :  Channel Layout  : Loudspeaker Location Ordering
             0000           :       Mono       : C
             0001           :      Stereo      : L/R
             0010           :      5.1ch       : L/C/R/Ls/Rs/LFE
             0011           :     5.1.2ch      : L/C/R/Ls/Rs/Ltf/Rtf/LFE
             0100           :     5.1.4ch      : L/C/R/Ls/Rs/Ltf/Rtf/Ltr/Rtr/LFE
             0101           :      7.1ch       : L/C/R/Lss/Rss/Lrs/Rrs/LFE
             0110           :     7.1.2ch      : L/C/R/Lss/Rss/Lrs/Rrs/Ltf/Rtf/LFE
             0111           :     7.1.4ch      : L/C/R/Lss/Rss/Lrs/Rrs/Ltf/Rtf/Ltb/Rtb/LFE
             1000           :     3.1.2ch      : L/C/R//Ltf/Rtf/LFE
            others          :     reserved     :
</pre>

```
Where, C: Center, L: Left, R: Right, Ls: Left Surround, Lss: Left Side Surround, Rs: Right Surround, Rss: Right Side Surround, 
Ltf: Left Top Front, Rtf: Right Top Front, Ltr: Left Top Rear, Rtr: Right Top Rear, 
Ltb: Left Top Back, Rtb: Right Top Back, LFE: Low-Frequency Effects
```

<dfn noexport>output_gain_is_present_flag</dfn> shall indicate if output_gain information fields for the ChannelGroup presents .
- 0: No output_gain information fields for the ChannelGroup present.
- 1: output_gain information fields for the ChannelGroup present. In this case, output_gain_flags and output_gain fields present.

<dfn noexport>recon_gain_is_present_flag</dfn> shall indicate if recon_gain information fields for the ChannelGroup presents in Recon_Gain_Info().
- 0: No recon_gain information fields for the ChannelGroup present in Recon_Gain_Info_OBU.
- 1: recon_gain information fields for the ChannelGroup present in Recon_Gain_Info_OBU. In this case, recon_gain_flags and recon_gain fields present.


<dfn noexport>loudness</dfn> shall indicate the loudness value of the downmixed channels, for the channel layout which is indicated by loudspeaker_layout, from the original channel audio. It shall be stored in fixed-point value with 8 fractional bits (i.e. Q7.8 in [[!Q-Format]]) and shall be [=LKFS=] based on [[!ITU1770-4]], so it shall be to represent zero or negative value.

<dfn noexport>output_gain_flags</dfn> shall indicate the channels which output_gian is applied to. If a bit set to 1, output_gain shall be applied to the channel. Otherwise, output_gain shall not be applied to the channel.


<pre class = "def">
Bit position : Channel Name
    b5(MSB)  : Left channel (L1, L2, L3)
      b4     : Right channel (R2, R3)
      b3     : Left Surround channel (Ls5)
      b2     : Right Surround channel (Rs5)
      b1     : Left Top Front channel (Ltf)
      b0     : Rigth Top Front channel (Rtf)

</pre>

<dfn noexport>output_gain</dfn> shall indicate the gain value to be applied to the mixed channels which are indicated by output_gain_flags. It is 20*log10 of the factor by which to scale the mixed channels. It is stored in a 16-bit, signed, two’s complement fixed-point value with 8 fractional bits (i.e. Q7.8 in [[!Q-Format]]). Where, each mixed channel is generated by downmixing two or more input channels.


### Ambisonics Config Syntax and Semantics ### {#syntax-ambisonics-config}

[=ambisonics_config()=] shall contain information regarding the configuration of Ambisonics.

<b>Syntax</b>

```
class ambisonics_config() {
  unsigned int (leb128()) ambisonics_mode;
  if (ambisonics_mode == MONO) {
    ambisonics_mono_config();
  } else if (ambisonics_mode == PROJECTION) {
    ambisonics_projection_config();
  }
}

class ambisonics_mono_config() {
  unsigned int(8) output_channel_count (C);
  unsigned int(8) substream_count (N);
  unsigned int(8 * C) channel_mapping;
}

class ambisonics_projection_config() {
  unsigned int(8) output_channel_count (C);
  unsigned int(8) substream_count (N);
  unsigned int(8) coupled_substream_count (M);
  unsigned int(16 * (N + M) * C) demixing_matrix;
}
```

<b>Semantics</b>

<dfn noexport>ambisonics_mode</dfn> shall specify the method of coding Ambisonics.

<pre class = "def">
ambiosnics_mode: Method of coding Ambisonics.
   0    : MONO
   1    : PROJECTION
</pre>

If ambisonics_mode is equal to MONO, this shall indicate that the Ambisonics channels are coded as individual mono substreams.

If ambisonics_mode is equal to PROJECTION, this shall indicate that the Ambisonics channels are first linearly projected onto another subspace before coding as a mix of coupled stereo and mono substreams.

<dfn noexport>output_channel_count</dfn> shall be the same as [=channel count=] in [[!RFC8486].

<dfn noexport>substream_count</dfn> shall specify the number of audio substreams. It must be the same as [=num_substreams=] in its corresponding audio_element().

<dfn noexport>channel_mapping</dfn> shall be the same as the one for [=ChannelMappingFamily=] = 2 in [[!RFC8486]].

<dfn noexport>coupled_substream_count</dfn> shall specify the number of referenced substreams that are coded as coupled stereo channels, where M <= N.

<dfn noexport>demixing_matrix</dfn> shall be the same as the one for [=ChannelMappingFamily=] = 3 in [[!RFC8486]].


### Demixing Info Syntax and Semantics ### {#syntax-demixing-info}

<dfn noexport>demixing_info()</dfn> shall specify demixing parameter mode to be used to reconstruct output channel audio according to its [=loudspeaker_layout=].

<b>Syntax</b>

```
class demixing_info() {
  unsigned int (3) dmixp_mode;
  unsigned int (5) reserved;
}
```

<b>Semantics</b>

<dfn noexport>dmixp_mode</dfn> shall indicate a mode of pre-defined combinations of five demix parameters.
- 0: mode1, (alpha, beta, gamma, delta, w_idx_offset) = (1, 1, 0.707, 0.707, -1)
- 1: mode2, (alpha, beta, gamma, delta, w_idx_offset) = (0.707, 0.707, 0.707, 0.707, -1)
- 2: mode3, (alpha, beta, gamma, delta, w_idx_offset) = (1, 0.866, 0.866, 0.866, -1)
- 3: reserved
- 4: mode1, (alpha, beta, gamma, delta, w_idx_offset) = (1, 1, 0.707, 0.707, 1)
- 5: mode2, (alpha, beta, gamma, delta, w_idx_offset) = (0.707, 0.707, 0.707, 0.707, 1)
- 6: mode3, (alpha, beta, gamma, delta, w_idx_offset) = (1, 0.866, 0.866, 0.866, 1)
- 7: reserved

<dfn noexport>alpha</dfn> and <dfn noexport>beta</dfn> shall be gain values used for S7to5 down-mixer, <dfn noexport>gamma</dfn> for T4to2 down-mixer, <dfn noexport>delta</dfn> for S5to3 down-mixer and <dfn noexport>w_idx_offset</dfn> shall be the offset to generate a gain value <dfn noexport>w</dfn> used for T2toTF2 down-mixer.

<center><img src="images/Down-mix Mechanism.png" style="width:100%; height:auto;"></center>
<center><figcaption></b>IA Downmix Mechanism</figcaption></center>

### Recon Gain Info Syntax and Semantics ### {#syntax-recon-gain-info}

<dfn noexport>recon_gain_info()</dfn> shall contain recon gain values for demixed channels.

<b>Syntax</b>

```
class recon_gain_info() {
  for (i=0; i< channel_audio_layer; i++) {
    if (recon_gain_is_present_flag(i) == 1) {
      unsigned int(leb128()) recon_gain_flags(i);
      for (j=0; j< n(i); j++) {
        if (recon_gain_flag(i)(j) == 1)
          unsigned int (8) recon_gain;
      }
    }
  }
}
```

<b>Semantics</b>

<dfn noexport>recon_gain_flags</dfn> shall indicate the channels which recon_gain is applied to.

<left><img src="images/Recon_Gain_Flags.png" style="width:100%; height:auto;"></left>

<dfn noexport>recon_gain</dfn> shall indicate the gain value to be applied to the channel, which is indicated by [=recon_gain_flags=], after decoding of the following associated frames.

### Rendering Config Syntax and Semantics ### {#syntax-rendering-config}

To be added

<b>Syntax</b>

```
class rendering_config() {
  // TODO
}
```

<b>Semantics</b>

### Element Mix Config Syntax and Semantics ### {#syntax-element-mix-config}

To be added

<b>Syntax</b>

```
class element_mix_config() {
  // TODO
}
```

<b>Semantics</b>

### Mix Bus Config Syntax and Semantics ### {#syntax-mix-bus-config}

To be added

<b>Syntax</b>

```
class mix_bus_config() {
  // TODO
  drc_config();
}
```

class drc_config() {
	// TODO
}

<b>Semantics</b>

### Mix Loudness Info Syntax and Semantics ### {#syntax-mix-loudness-info}

To be added

<b>Syntax</b>

```
class mix_loudness_info() {
  // TODO
}
```

<b>Semantics</b>

## Codec Specific ## {#codec-specific}

This section defines codec specific information for Codec_Specific_Info and Substream.

- <dfn noexport>Codec_Specific_Info</dfn> shall be composed of [=Codec_ID=] and [=Decoder_Config()=]. Codec_ID shall indicate the codec which has been used to generate a given substream within IA bitstream and Decder_Config() shall indicate the decoding parameters which are applied to the substream within IA bitstream.

For legacy codecs, Decoder_Config() shall be exactly the same information as the conventional file parser feeds to the codec decoders for decoding of the substream. For future codecs, Decder_Config() shall include all of decoding parameters which are required to decode Substreams.

- Substream shall be a raw coded stream for one or more channels. Substream format shall be exactly the same as the sample format (before packing OBU and except parameter blocks) for the audio file which consists of only one single coded stream by the Codec_ID.


### IAC-OPUS Specific ### {#iac-opus-specific}

Codec_Specific_Info for IAC-OPUS shall conform to [=ID Header=] with [=ChannelMappingFamily=] = 0 of [[!RFC7845]] with following constraints:
- [=Channel Count=] should be set to 2.
- [=Output Gain=] shall not be used. In other words, it shall be set to 0dB.

Substream format shall be [=opus packet=] of [[!RFC6716]] which contains only one single frame of mono or stereo channels.


### IAC-AAC-LC Specific ### {#iac-aac-lc-specific}

[=Codec_ID=] shall be 'mp4a'.

[=Decoder_Config()=] for IAC-AAC-LC shall be [=DecoderConfigDescriptor()=] of [[!MP4-Systems]], which is a subset of [=ESDBox=] for [[!MP4-Audio]], with following constraints:
- [=objectTypeIndication=] = 0x40
- [=streamType=] = 0x05 (Audio Stream)
- [=upstream=] = 0
- [=decSpecificInfo()=]: The syntax and values shall conform to [=AudioSpecificConfig()=] of [[!MP4-Audio]] with following constraints:
	- [=audioObjectType=] = 2
	- [=channelConfiguration=] should be set to 2.
	- [=GASpecificConfig()=]: The syntax and values shall conform to [=GASpecificConfig()=] of [[!MP4-Audio]] with following constraints:
		- [=frameLengthFlag=] = 0 (1024 lines IMDCT)
		- [=dependsOnCoreCoder=] = 0
		- [=extensionFlag=] = 0

Substream format shall be [=raw_data_block()=] of [[!AAC]] which contains only one single frame of mono or stereo channels.

### IAC-FLAC Specific ### {#iac-flac-specific}

[=Codec_ID=] shall be 'fLaC', the FLAC stream marker in ASCII, meaning byte 0 of the stream is 0x66, followed by 0x4C 0x61 0x43.

[=Decoder_Config()=] for IAC-FLAC shall be [=METADATA_BLOCK=] of [[!FLAC]].

Substream format shall be [=FRAME=] of [[!FLAC]], which is composed of [=FRAME_HEADER=], followd by [=SUBFRAME=](s) (one [=SUBFRAME=] per channel) and followed by [=FRAME_FOOTER=].

### IAC-LPCM Specific ### {#iac-lpcm-specific}

[=Codec_ID=] shall be 'lpcm'.

[=Decoder_Config()=] for IAC-LPCM shall be as follows:

```
class decoder_config(lpcm) {
  unsigned int (32) sample_rate;
}
```

<dfn noexport>sample_rate</dfn> shall indicate the sample rate of the input audio in Hz. It shall be little endian.

Substream format shall be the audio samples for the frame size.


# Profiles # {#profiles}

The IA Profiles define a set of capabilities that are required to decode the coresponding IA sequence.

Additionally, the following restrictions shall apply to all profiles:

0. IA sequence shall composed of a sequence of one or more IA bitstreams.
1. IA bitstream shall be composed of a series of OBUs with starting one single OBU_Start_Code, followed by the descriptor OBUs that make up the global descriptor, namely one OBU_IA_Codec_Config, followed by one or more OBU_IA_Audio_Element, followed by zero or more OBU_Mix_Presentation and followed by zero or more OBU_IA_Parameter_Block and one or more OBU_IA_Audio_Frame.
2. The descriptor OBUs shall identify the configuration of following one or more audio elements.
3. If OBU_IA_Parameter_Block is present, the global descriptor shall be followed by one or more parameter blocks. The one or more parameter blocks may redundantly contain information specified by previous parameter blocks that are still valid for the time after the descriptor OBUs.
4. Substream IDs may be omitted if the audio frames from the various audio substreams are ordered in the bitstream in well-defined way that remains unchanged, such that an implicit ordering can be reliably inferred. In a bitstream, the substream IDs shall be either included for all substreams or omitted for all substreams; the bitstream shall not have a combination of both.

## IA Simple Profile ## {#iaprofiles-simple}

This section defines the simple profile for IA sequence and IA decoder and specifies the conformance points of this profile.

Restrictions on IA sequence:
- All of IA bitstreams in IA sequence shall have the same OBU_Start_Code and the same descriptor OBUs.
- [=version=] shall be set to 0 for this version of specification.
- [=profile_version=] shall be set to 0 for this version of specification.
- Only one single OBU_IA_Audio_Element shall be present.
- [=num_layers=] shall be set to 1 for channel-based audio element (i.e. non-scalable channel audio)
    - In this case, OBU_IA_Parameter_Block including demixing_info() may be present in the IA bitstream.
- [=substream_id_mode=] in codec_config_obu() shall be set to ALL.
- All audio frames shall have aligned frame boundaries.
- There shall not be OBU_IA_Sync present.
- All parameter blocks (if present) shall be synced relative to the frame boundary of the audio frame that comes immediately after.
- obu_id_flag, obu_sync_flag, obu_duration_flag and obu_counter_flag of every OBU_IA_Audio_Frame shall be set to 0.

Capabilities of IA decoder:
- IA decoder which is conformant to this profile shall be able to decode IA bitsteam with the MSB four bits of [=profile_version=] = 0 and the MSB four bits of [=version=] = 0 (i.e., profile_version = 0 to 15 and version = 0 to 15).
- IA decoder which is conformant to this profile shall be able to decode up to 16 channels.
- IA decoder which is conformant to this profile shall be able to decode up to at most one audio element.
- IA decoder which is conformant to this profile shall be able to decode channel-based audio element.
- IA decoder which is conformant to this profile shall be able to decode scene-based audio element.
- IA decoder which is conformant to this profile may do down-mixing by using demixing_info().

## IA Base Profile ## {#iaprofiles-base}

This section defines the base profile for IA sequence and IA decoder and specifies the conformance points of this profile.

Restrictions on IA sequence:
- All of IA bitstreams in IA sequence may not have the same descriptor OBUs.
- [=version=] shall be set to 0 for this version of specification.
- [=profile_version=] shall be set to 16 for this version of specification.
- One or two OBU_IA_Audio_Element shall be present through IA sequence.
- [=num_layers=] shall be set to 1 or up to 6 for Channel-based audio element (i.e. scalable channel audio)
    - In this case, [=demixing_info()=] and [=recon_gain_info()=] may be present in the IA bitstream.
  - In case of simple scalable channel audio (e.g. mono for layer 1 & stereo for layer 2), [=demixing_info()=] and [=recon_gain_info()=] shall not be present in the bitstream.
- [=substream_id_mode=] in codec_config_obu() shall be set to ALL.
- All audio frames shall have aligned frame boundaries.
- There shall not be OBU_IA_Sync present.
- All parameter blocks (if present) shall be synced relative to the frame boundary of the audio frame that comes immediately after.
- obu_id_flag, obu_sync_flag, obu_duration_flag and obu_counter_flag of every OBU_IA_Audio_Frame shall be set to 0.

Capabilities of IA decoder:
- IA decoder which is conformant to this profile shall be able to decode IA bitsteam with the MSB four bits of [=profile_version=] = 0 or 1 and the MSB four bits of [=version=] = 0 (i.e., profile_version = 0 to 31 and version = 0 to 15).
- IA decoder which is conformant to this profile shall be able to support the capabilities of IA decoder with simple profile.
- IA decoder which is conformant to this profile shall be able to decode up to 16 channels.
- IA decoder which is conformant to this profile shall be able to decode up to at most two audio elements.
- IA decoder which is conformant to this profile shall be able to decode scalable channel audio.
- IA decoder which is conformant to this profile shall be able to decode scene-based audio element.
- IA decoder which is conformant to this profile shall be able to decode short-lived contents which is coming during decoding an audio element.
- IA decoder which is conformant to this profile shall be able to mix two audio elements.

## IA Enhanced Profile ## {#iaprofiles-Enhanced}

This section defines the enhanced profile for IA sequence and IA decoder and specifies the conformance points of this profile.

Restrictions on IA sequence:
- All of IA bitstreams in IA sequence may not have the same descriptor OBUs.
- [=version=] shall be set to 0 for this version of specification.
- [=profile_version=] shall be set to 32 for this version of specification.
- The different codec_config_obu()s may have different [=codec_id=]s specified.
    - Nevertheless, the combination of [=codec_id=] = 'fLaC' for one substream and [=codec_id=] = 'opus' for another substream shall not be allowed.
    - The combination of [=codec_id=] = 'fLaC' for one substream and [=codec_id=] = 'mp4a' for another substream shall not be allowed.

- [=num_layers=] shall be set to 1 or up to 6 for Channel-based audio element (i.e. scalable channel audio)
    - In this case, [=demixing_info()=] and [=recon_gain_info()=] may be present in the IA bitstream.
    - In case of simple scalable channel audio (e.g. mono for layer 1 & stereo for layer 2), [=demixing_info()=] and [=recon_gain_info()=] shall not be present in the bitstream.
- There shall be OBU_IA_Sync present unless [=substream_id_mode=] in codec_config_obu() is set to ALL.
- All parameter blocks shall be synced relative to the immediately preceding OBU_IA_Sync.

Capabilities of IA decoder:
- IA decoder which is conformant to this profile shall be able to decode IA bitsteam with the MSB four bits of [=profile_version=] = 0, 1 or 2 and the MSB four bits of [=version=] = 0 (i.e., profile_version = 0 to 47 and version = 0 to 15).
- IA decoder which is conformant to this profile shall be able to support the capabilities of IA decoder with base profile.
- IA decoder which is conformant to this profile shall be able to decode up to 36 channels.
- IA decoder which is conformant to this profile shall be able to decode audio elements coded by two different audio codecs except both the combination of IAC-FLAC and IAC-OPUS and the combination of IAC-FLAC and IAC-AAC-LC.
- IA decoder which is conformant to this profile shall be able to support the synchronization of two or more audio elements with different frame sizes.

# Standalone IAC Representation # {#standalone}

ISSUE: Needs a lot more details.

- Global descriptors come first. This includes:
    - Start Code OBU
    - Codec config OBU
    - Audio Element OBU
    - Mix Presentation OBU
- Followed by a series of:
    - Sync OBU
    - Optionally, Parameter Block OBUs, synced relative to the previous Sync OBU
    - Audio Frame OBUs, synced relative to the previous Sync OBU.

Global descriptors to be repeated frequently as needed to enable joining mid-stream. This must be followed by parameter OBUs that redundantly copy previous parameter OBUs that are still valid for the time after the global descriptors. I.e. decoders joining mid-stream that encounters a Start Code OBU knows that it will receive information in the next OBUs that give it complete information to start decoding following audio frames.

Sync OBUs may be placed as frequently as needed in the bitstream.

Parameter blocks may be placed as frequently as needed in the bitstream.

ISSUE: TODO: need to include more information about packing order of OBUs, timing and synchronizing the OBUs.

ISSUE: Below is copy-pasted from old version ("Immersive Audio Bitstream Definition"). TODO: refactor and update.

## Immersive Audio Bitstream Definition ## {#iabitstream-definition}

An immersive audio (IA) sequence shall include one or more audio elements, each of which shall consist of one or more audio substreams. IA sequence shall start with IA_Stream_Indicator and followed by a sequence of IA bitstreams.

Each IA bitstream shall be self-decodable and shall be composed of one single global metadata and followed by one or more [=access unit=]s.
- <dfn noexport>access unit</dfn> shall be composed of optional update metadata and followed by [=audio frames=].
- Where, <dfn noexport>audio frames</dfn> is a set of one or more audio substream frames with the same frame size and the same sync offsets.

There can be two types of IA bitstreams. The first is an IA bitstream with one single frame size and the second is an IA bitstream with two or more different frame sizes. The conceptual diagrams are shown in the two figures below.

<center><img src="images/Immersive Audio Bitstream with one single frame size (before OBU packing).png" style="width:100%; height:auto;"></center>
<center><figcaption>Immersive Audio Bitstream with one single frame size (before OBU packing).</figcaption></center>

In the first type of IA bitstream with one single frame size, all [=audio substreams=] in the same IA bitstream shall have the same audio_substream_config().

After OBU packing, temporal_delimiter_obu shall be present at the front of every access unit to indicate the start of the access unit.

In this case, [=audio frames=] depicted in the diagram above is a set of audio substream frames with the same sync offsets.
- [=Audio frames=] #i is composed of Ni number of frames, each of them is frame #i of each substream. Where, i = 1, 2, ..., k.

<center><img src="images/Immersive Audio Bitstream with two frame sizes (before OBU packing).png" style="width:100%; height:auto;"></center>
<center><figcaption>Immersive Audio Bitstream with two frame sizes (before OBU packing).</figcaption></center>

In the second type of IA bitstream with two or more frame sizes, the audio substreams in the same IA bitstream may have different audio_substream_config() with different [=num_samples_per_frame=].

The diagram above depicts an example case where there are two frame sizes in the same IA bitstream. In this case, [=audio frames=] is a set of audio substream frames with the same sync offsets and the same frame size.
- [=Audio frames=] #i1 for frame size 1 is composed of Ni1 number of frames, each of them is frame #i1 of each substream. Where, i1 = 1, 2, ..., k1.
- [=Audio frames=] #i2 for frame size 2 is composed of Ni2 number of frames, each of them is frame #i2 of each substream. Where, i2 = 1, 2, ..., k2.



## Bitstream Packing ## {#bitstream-packing}

All metadata within an IA bitstream contains synchronization information that includes the sync offset and the duration for which it is valid. This is used when determining the order in which the metadata is packed in the bitstream.

- The global and update metadata, and audio substreams, should be packed chronologically according to their sync offset.
- If there are multiple metadata and audio substreams with the same sync offset, they should be packed in the following order:
    1. Global metadata
    2. Update metadata
    3. Audio substreams
- Within a sequence of metadata or audio substreams with the same sync offset, ordering does not matter if they have associated IDs.

As an illustrative example, consider a bitstream that contains the following:

1. Two substreams, one coded with Codec A and the second coded with Codec B.
		- Codec A has a frame size of 20 ms.
		- Codec B has a frame size of 30 ms.
2. Three parameters with different update rates.
		- Parameter A has an update rate of 10 ms.
		- Parameter B has an update rate of 40 ms.
		- Parameter C has a variable update rate.

The figure below shows the metadata and substreams, and the bitstream packing for this example.

<center><img src="images/bitstream_packing.svg" style = "width: 100%; height: 100%;"></center>
<center><figcaption>Example of how substreams and parameter metadata with different update rates should be packed in the bitstream.</figcaption></center>


# ISOBMFF IAC Encapsulation # {#isobmff}

## General Requirements & Brands ## {#brands}

A file conformant to this specification satisfies the following:
- It shall conform to the normative requirements of [[!ISOBMFF]]
- It shall have the <dfn value export for="ISOBMFF Brand">aiac</dfn> brand among the compatible brands array of the FileTypeBox
- It shall contain at least one track using an [=IASampleEntry=]
- It SHOULD indicate a structural ISOBMFF brand among the compatible brands array of the FileTypeBox, such as 'iso6'
- It MAY indicate other brands not specified in this specification provided that the associated requirements do not conflict with those given in this specification

Parsers shall support the structures required by the <code>'iso6'</code> brand and MAY support structures required by further ISOBMFF structural brands.


## ISOBMFF IAC Encasulation with single track ## {#isobmff-singletrack}

This section describes the basic data structures used to signal encapsulation of IA sequence in [[!ISOBMFF]] containers.

Map the OBUs to ISOBMFF boxes as follows:
- Start Code OBU: version and profile_version move to a sample entry.
- Codec Config OBU: place in a sample entry.
- Audio Element OBU: place in sample groups.
- Mix Presentation OBU: place in sample groups.
- Parameter Block OBUs: place in either Sample Groups or Samples. A combination of both is allowed. Decision is left to the encoder, perhaps it can be decided based on sparsity of parameters (for bit-rate savings).
- Audio Frame OBU: one per Sample.
- Sync OBU: omitted

During encapsulation process, OBUs of IA bistream are encapsulated into [[!ISOBMFF]] as follows:
- IA sequence shall comply with simple or base profile. In other word, all substreams in IA sequence shall have the same codec_config().
- codec_id and decoder_config() of codec_config() shall be stored in IA sample entry.
- audio_element_obu() and mix_presentation_obu() (with obu syntax) shall be stored as a new sample group having [=grouping_type=], [=iagd=].
- version and profile_version, related to MIME codecs parameter, shall be moved in IA sample entry.
- parameter_block_obu for demixing_info() (with OBU syntax) may be stored as a new sample group having [=grouping_type=], [=demi=].
- Each access unit shall be stored as sample data without gap among OBUs.

### IA Sample Entry ### {#iasampleentry-section}

<pre class="def">
	Sample Entry Type: <dfn value export for="IASampleEntry">aiac</dfn>
	Container:         Sample Description Box ('stsd')
	Mandatory:         Yes
	Quantity:          One or more.
</pre>


The <dfn noexport>IASampleEntry</dfn> identifies that the track contains [=IA Samples=], and uses one single [=codec specific box=].

<b>Syntax</b>

```
class IASampleEntry extends AudioSampleEntry('aiac') {
  unsigned int (8) version;
  unsigned int (8) profile_version;
  CodecSpecificBox config;
}
```

No optional boxes of AudioSampleEntry shall present.

<b>Sematics</b>

Both [=channelcount=] and [=samplerate=] fields of AudioSampleEntry shall be ignored.

version and profile_version shall be the same as the ones in start_code_obu.


### Codec Specific Box ### {#codecspecificbox-section}

This section describes a <dfn noexport>codec specific box</dfn> for the decoding parameters, which is defined by codec_id of audio_substream_config(), to decode one single substream of IA bitstream. <code>aiac</code> shall contain only one single codec specific box regardless of the number of substreams in IA bitstream. So, the codec specific box is applied to all of substreams in sample data.

#### OPUS Specific Box #### {#codecspecificbox-opus}

This shal be [=OpusSpecificBox=] ('dOps') for 'opus' audiosampleentry which is specified in [[!OPUS-IN-ISOBMFF]].

<pre class="def">
	Box Type:  <dfn export>dOps</dfn>
	Container: IA Sample Entry ('aiac')
	Mandatory: Yes
	Quantity:  One
</pre>


This box shall be for one single substream.

<b>Syntax</b>

It shall be the same as 'dOps' box for 'opus' with that [=ChannelMappingFamily=] shall be set to 0.

<b>Sematics</b>

It shall be the same as the semantics except followings:
- [=OutputChannelCount=] should be set to 2. [=OutputChannelCount=] can be ignored because the real value can be determined from the IA_Static_Meta_OBU and from the [=opus packet=] header.
- In case of channel_audio_layer > 0, [=OutputGain=] shall be set to 0.
- [=ChannelMappingFamily=] shall be set to 0.

#### MP4A Specific Box #### {#codecspecificbox-mp4a}

This shall be [=ESDBox=] ('esds') for 'mp4a' which is specified in [[!MP4]].


<pre class="def">
	Box Type:  <dfn export>esds</dfn>
	Container: IA Sample Entry ('aiac')
	Mandatory: Yes
	Quantity:  One of more
</pre>


This box shall be for one single Substream.

<b>Syntax</b>

It shall be the same as 'esds' box for [=Low Complexity Profile=] of [[!AAC]] (AAC-LC).

<b>Semantics</b>

It shall be the same as the semantics except followings:
- [=channelConfiguration=] field should be set to 2. The real value can be implied from the global_metadata_obu.

ISSUE: We need to add specific boxes for FLAC and LPCM.

### IA Sample Format ### {#iasampleformat}

For tracks using the [=IASampleEntry=], an <dfn noexport>IA Sample</dfn> has the following constraints:
- The sample data shall be a sequence of OBUs forming a access unit.
- OBUs for parameter blocks (if present) come first and followed by OBU(s) for audio substream frame(s).
- Each OBU shall comply with OBU syntax as specified in this specificaiton.

### IA Sample Group ### {#iasamplegroup}

#### Global Descriptor Sample Group #### {#iasamplegroup-globaldescriptor}

During encapsulation process, global descriptor are discarded from each IA bistream. A new sample group for global descriptor shall be defined by using 'sgpd' and 'sbgp' boxes with following requirements:
- [=grouping_type=] shall be set to <dfn noexport>iagd</dfn>.
- [=SampleGroupDescriptionEntry=] shall be one or more audio_element_obu and followed by zero or more mix_presentation_obu with OBU syntax.

### Demixing Info Sample Group ## {#iasamplegroup-demixing}

During encapsulation process, parameter_block_obu for demixing_info shall be discarded from IA sequence. A new sample group for demixing_info() shall be defined by using 'sgpd'' and 'sbgp' boxes with following requirements:
- [=grouping_type=] shall be set to <dfn noexport>demi</dfn>.
- Each [=SampleGroupDescriptionEntry=] shall be parameter_block_obu for demixing_info with OBU syntax.


## Common Encryption ## {#CommonEncryption}
TBA

## Codecs Parameter String ## {#codecsparameter}
DASH and other applications require defined values for the 'Codecs' parameter specified in [[!RFC6381]] for ISO Media tracks. The codecs parameter string for the AOM IA codec shall be:
- For IAC-OPUS

```
	aiac.IAC-specific-needs.Opus
```

- For IAC-AAC-LC

```
	aiac.IAC-specific-needs.mp4a.40.2
```

- For IAC-FLAC

```
	aiac.IAC-specific-needs.fLaC
```

- For IAC-LPCM

```
	aiac.IAC-specific-needs.lpcm
```

<b>IAC-specific-needs</b> shall be <b>V.PV</b> as follows:
- <dfn noexport>V</dfn> shall be four digits and shall represent the version of IA sequence.
	- The first two digits shall represent the major version within the range 0 to 15.
	- The second two digits shall represent the minor version within the range 0 to 15.
- <dfn noexport>PV</dfn> shall be four digits and shall represent the profile version of IA sequence.
	- The first <b>P</b> shall be two digits and shall represent the profile major version within the range 0 to 15.
	- The second <b>V</b> shall be two digits and shall represent the profile minor version within the range 0 to 15.

For example, for this version of the specification
- The codecs parameter string of IAC-OPUS for the simple profile:

```
	aiac.0000.0000.Opus
```

- The codecs parameter string of IAC-AAC-LC for the base profile:

```
	aiac.0000.0100.mp4a.40.2
```


# IAC processing # {#processing}

ISSUE: Copy-pasted from old version, will need updating.

This section provides a guideline for IA decoding for a given [=IA bitstream=].

## IA Decoder ## {#iadecoding-iadecoder}

IA decoder can select one of three decoding modes based on Ambisonics_Mode and Channel_Audio_Layer in IA_Static_Meta.
- Ambisonics decoding in case of Ambisonics_Mode !=0 and Channel_Audio_Layer = 0.
- Channel Audio decoding in case of Ambisonics_Mode = 0 and Channel_Audio_Layer > 0.
- Ambisonics + Channel Audio decoding in case of Ambisonics_Mode != 0 and Channel_Audio_Layer > 0.

<b>Abmisonics decoding</b>, it shall conform to [[!RFC8486]] except codec specific processing and shall output Ambisonics channels in ACN (Ambisonics Channel Number) order.

<b>Channel Audio decoding</b>, it shall output the channel audio (e.g. 3.1.2ch or 7.1.4ch) for the target channel layout.

<b>Ambisonics + Channel Audio decoding</b>, it shall output both of Ambisonics channels and the channel audio for the target channel layout.
- In this case, implementors may have additional processing converting Ambisonics to Channel Audio (including Binaural) but it is not specified in this specification.

IA decoder is composed of OBU parser, Codec decoder and Post-processor as depicted in below figure.
- OBU parser depacketizes IA bitstream to output one or more Substreams with one single Decoder_Config, IA_Static_Meta and Timed Metadata.
	- OBU parser is composed of Non-timed Metadata parser and Temporal Unit parser.
		- Non-timed Metadata parser depacketizes OBUs for Codec_Specific_Info and IA_Static_Meta, and figures out the configuration of IA bitstream including the codec to decoder Substreams.
		- Temporal Unit parser depacketizes OBUs for each Temporal Unit and outputs Timed Metadata and Substreams for each frame.
	- One or more Substreams with one single Decoder_Config are passed to Codec decoder.
	- IA_Static_Meta and Timed Metadata for each frame are passed to Post-processor.
	- For IAC-OPUS, Substream is one single [=opus packet=] of [[!RFC6716]] which has non-delimiting frame structure and for IAC-AAC-LC, Substreams is one single [=raw_data_block()=] of [[!AAC]].
- Codec decoder prepares the Mono/Stereo decoders as many as the number of Substreams. Each Mono/Stereo decoder is initialized with Decoder_Config and decodes Substream.
	- Each Mono/Stereo decoder outputs one or two channels to Post-processor.
- Post-processor outputs Ambisonics and/or Channel Audio based on the decoding mode.
	- Post-processor is composed of Ambiosonics processor and Channel Audio processor.
	- Post-processor figures out the configuration of ChannelGroups based on IA_Static_Meta.
	- Ambisonics processor outputs Ambisonics channels in ACN order by applying [=Channel_Mapping=] or [=Demixing_Matrix=] to the first ChannelGroup.
	- Channel Audio processor outputs channel audio for the target channel layout after some processing of the relevant ChannelGroups by using Timed Metadata if needed.

<center><img src="images/IA Decoder Configuration.png" style="width:100%; height:auto;"></center>
<center><figcaption>IA Decoder Configuration</figcaption></center>

### IA Decoder for Ambisonics decoding ### {#iadecoding-iadecoder-ambisonics}

This section describes IA decoding operation for Ambisonics.

Below figure shows the decoding flowchart of Ambisonics decoding.
- OBU parser shall output the first Substreams, among Substream in IA bitstream, as many as [=substream_count=] specified in ambix_layer_config of IA_Static_Meta, with Decoder_Config.
	- OBU parser shall output [=channel_mapping=] or [=demixing_matrix=] according to [=Ambisonics_Mode=] to Channel_Mapping/Demixing_Matrix module
- Codec decoder shall output decoded channels (PCM) in the transmission order as many as as many as [=output_channel_count=] after decoding of each Substream.
- Channel_Mapping/Demixing_Matrix module applies channel_mapping or demixing_matrix according to Ambisonics_Mode to the channels (PCM) and outputs channels as many as [=output_channel_count=] in ACN order.

<center><img src="images/Ambisonics Decoding Flowchart.png" style="width:100%; height:auto;"></center>
<center><figcaption>Ambisonics Decoding Flowchart</figcaption></center>

### IA Decoder for Channel Audio decoding ### {#iadecoding-iadecoder-channelaudio}

This section describes IA decoding operation for Channe Audio.

Below figure shows the decoding flowchart of Channel Audio decoding.

<center><img src="images/Channel Audio Decoding Flowchart.png" style="width:100%; height:auto;"></center>
<center><figcaption>Channel Audio Decoding Flowchart</figcaption></center>

For a given target channel layout (i.e. CL #i) among the list of [=loudspeaker_layout=] in IA_Static_Meta,
- OBU Parser shall get Substreams for ChannelGroup #1 ~ ChannelGroup #i and pass them to Codec decoder with [=Decoder_Config()=].
- Codec decoder shall output decoded channels (PCM) in the transmission order.
	- For non-scalable audio (i.e i = 1), its order shall be converted to the loudspeaker location order for CL #1.
	- For scalable audio, its order shall be converted to the loudspeaker location order for CL #i after going through necessary modules such as Gain, De-Mixer, Recon_Gain etc..
- When Output_Gain_Is_Present_Flag(j) for ChanneGroup #j (j = 1, 2, …, i-1) is on, Gain module shall apply Output_Gain(j) to all audio samples of the mixed channels in the ChannelGroup #j indicated by Output_Gain_Flag(j).
- De-Mixer shall output de-mixed channels (PCM) for CL #i generated through de-mixing of the mixed channels from Gain module by using non-mixed channels and demixing parameters for each frame.
- Recon_Gain module shall output smoothed channels (PCM) by appling Recon_Gain to each frame of the de-mixed channels.
- Loudness normalization module may output loudness normalized channels at -24 LKFS from non-mixed channels and smoothed channels (if present) by using loudness value for CL #i.
- DRC control module may apply the pre-defined DRC compression to the loudness normalized channels, after that it outputs loudness normalized channels at -16 LKFS.
- Limiter module may limit the true peak of input channels at -1dB.

Following sections, [[#iadecoding-iadecoder-channelaudio-gain]], [[#iadecoding-iadecoder-channelaudio-demixer]] and [[#iadecoding-iadecoder-channelaudio-recongain]] are only needed for decoding of scalable audio.
[[#iadecoding-iadecoder-channelaudio-loudness]] and [[#iadecoding-iadecoder-channelaudio-drc]] may not be recommended according to application.

#### Gain #### {#iadecoding-iadecoder-channelaudio-gain}

Gain module is the mirror process of Attenuation module. It recovers the reduced sample values using Output_Gain when its flag for ChannelGroup #j is on. When its flag is off, then this module shall be bypassed for ChannelGroup #j. Output_Gain(j) for ChannelGroup #j shall be applied to all samples of the mixed channels in the ChannelGroup #j. Where, mixed channels means the mixed channels from an input channel audio (i.e. a channel audio for CL #n).

To apply the gain, an implementation MUST use the following:

```
	Sample *= pow(10, Output_Gain(j) / (20.0*256))
```

Where, Output_Gain(j) is the raw 16-bit value from IA_Static_Meta.

#### De-mixer #### {#iadecoding-iadecoder-channelaudio-demixer}

For scalable audio, some channels of [=down-mixed audio=] for CL #i are delivered as is but the rest are mixed with other channels for CL #i-1.

De-mixer module reconstructs the rest of the down-mixed audio for CL #i from the mixed channels, which is passed by Gain module, and its relevant non-mixed channels using its relevant demixing parameters.

De-mixing for down-mixed audio for CL #i shall comply with a combination of following surround and top de-mixers:
- Surround de-mixers
	- <dfn noexport>S1to2 de-mixer</dfn>: R2 = 2 x Mono – L2
	- <dfn noexport>S2to3 de-mixer</dfn>: L3 = L2 – 0.707 x C and R3 = R2 – 0.707 x C
	- <dfn noexport>S3to5 de-mixer</dfn>: Ls = 1/δ(k) x (L3 – L5) and Rs = 1/δ(k) x (R3 – R5)
	- <dfn noexport>S5to7 de-mixer</dfn>: Lrs = 1/β(k) x (Ls – α(k) x Lss) and Rrs = 1/β(k) x (Rs – α(k) x Rss)
- Top de-mixers
	- <dfn noexport>TF2toT2 de-mixer</dfn>: Ltf2 = Ltf3 – w(k) x (L3 – L5) and Rtf2 = Rtf3 – w(k) x (R3 – R5)
	- <dfn noexport>T2to4 de-mixer</dfn>: Ltb = 1/γ(k) x (Ltf2 – Ltf4) and Rtb = 1/γ(k) x (Rtf2 – Rtf4)
- Where, Ltf2 / Rtf2 is top channel of x.1.2ch, Ltf3 / Rtf3 is top channel of 3.1.2ch, and Ltf4 / Rtf4 is to channel of x.1.4ch (x = 5 or 7) and w(k) is determined from the value of wIdx(k).

Initially, wIdx(0) = 0 and the value of wIdx(k) shall be derived as follows:
- <dfn noexport>wIdx(k)</dfn> = Clip3 (wIdx(k-1) + w_idx_offset(k), 0, 10)
- Where, Clip3 (x, min, max) = max if x > max, min if x < min, x otherwise.

Mapping of wIdx(k) to w(k) is as follows:
<pre class = "def">
 wIdx(k) :   w(k)
    0    :    0
    1    :  0.0179
    2    :  0.0391
    3    :  0.0658
    4    :  0.1038
    5    :  0.25
    6    :  0.3962
    7    :  0.4342
    8    :  0.4609
    9    :  0.4821
    10    : 0.5
</pre>

When D_set = { x | S1 < x ≤ Si and x is an integer},
- If 2 is an element of D_set, the combination includes [=S1to2 de-mixer=].
- If 3 is an element of D_set, the combination includes [=S2to3 de-mixer=].
- If 5 is an element of D_set, the combination includes [=S3to5 de-mixer=].
- If 7 is an element of D_set, the combination includes [=S5to7 de-mixer=].

When Ti = 2,
- If Sj = 3 (j=1,2,…, i-1), the combination includes [=TF2toT2 de-mixer=].

When Ti = 4,
- If Sj = 3 (j=1,2,…, i-1), the combination includes [=TF2toT2 de-mixer=] and [=T2to4 de-mixer=].
- Elseif Tj = 2 (j=1,2,…, i-1), the combination includes [=T2to4 de-mixer=].

For example, when CL #1 = 2ch, CL #2 = 3.1.2ch, CL #3 = 5.1.2ch and CL #4 = 7.1.4ch. To reconstruct the rest (i.e. Ls5/Rs5/Ltf/Rtf) of th down-mixed 5.1.2ch,
- The combination includes [=S2to3 de-mixer=], [=S3to5 de-mixer=] and [=TF2toF2 de-mixer].
- Ls5 and Rs5 are recovered by S2to3 de-mixer and S3to5 de-mixer.
- Ltf and Rtf are recovered by S2to3 de-mixer and TF2toT2 de-mixer.

```
	Ls5 = 1/δ(k) × (L2 - 0.707 × C - L5) and Rs5 = 1/δ(k) × (R2 - 0.707 × C - R5).
	Ltf = Ltf3 - w(k) x (L2 - 0.707 x C - L5) and Rtf = Rtf3 - w(k) x (R2 - 0.707 x C - R5).
```

#### Recon Gain #### {#iadecoding-iadecoder-channelaudio-recongain}

[=Recon_Gain=] shall be only applied to all of audio samples of the de-mixed channels from De-mixer module.
- [=Recon_Gain_Info()=] indicates each channel of CL #i which Recon_Gain needs to be applied to and provides Recon_Gain value for each frame of the channel.
	- Sample (k,i) *= Smoothed_Recon_Gain (k,i), where k is the frame index and i is the sample index of the frame.
	- Smoothed_Recon_Gain (k) = MA_gain (k-1) x e_window + MA_gain (k) x s_window
	- MA_gain (k) = 2 / (N+1) x Recon_Gain (k) / 255 + (1 – 2/(N+1)) x MA_gain (k-1), where MA_gain (0) = 1.
	- e_window[:ps – olen] = 1, e_window[ps – olen: ps] = hanning[olen:], e_window[ps:flen] = 0.
	- s_window[:ps – olen] = 0, s_window[ps – olen: ps] = hanning[:olen], s_window[ps:flen] = 1.
	- Where, hanning = np.hanning (2*olen), ps is the pre-skip value, flen is the frame size and olen is the overlab size.
	- Recommend values: N = 7

Below figure shows the smoothing scheme of [=Recon_Gain=].

<center><img src="images/Smoothing Scheme of Recon Gain.png" style="width:100%; height:auto;"></center>
<center><figcaption>Smoothing Scheme of Recon Gain</figcaption></center>

Recommend values for specific codecs are as follows
- IAC-OPUS: olen = 60, the pre-skip (ps) value is indicated in Codec_Specific_Info for IAC-OPUS.
- IAC-AAC-LC: olen = 64, ps = 720.

#### Loudness Normalization #### {#iadecoding-iadecoder-channelaudio-loudness}

Loudness normalization is done by adjusting a loudness level to -24 LKFS based on the loudness value of the target channel layout (i.e. CL #i) which is signaled in [=Channel_Audio_Layer_Config()=].

Real implementations for [[#iadecoding-iadecoder-channelaudio-loudness]], [[#iadecoding-iadecoder-channelaudio-drc]] and [[#iadecoding-iadecoder-channelaudio-limiter]] are soly dependent on implementers (i.e., out of scope of this specification). This specification only recommends the principles for them.

#### DRC Control #### {#iadecoding-iadecoder-channelaudio-drc}

In this specification, DRC Control assumes an input loudness of -24 LKFS and targets an output loudness of -16 LKFS.

DRC Control module applies the pre-defined DRC compression by assuming a target loudness is adjusted to -16 LKFS as follows:
- DRC Segment 0
	- Threshold: not applicable
	- Ratio: 1:1
	- Type: Neutral
- DRC Segment 1
	- Threshold: -16.5 dBFS
	- Ratio: 1.5:1
	- Type: Compressor
- DRC Segment 2
	- Threshold: -9 dBFS
	- Ratio: 2:1
	- Type: Compressor
- DRC Segment 3
	- Threshold: -6 dBFS
	- Ratio: 3:1
	- Type: Compressor

Below figure shows the schematic diagram of the pre-defined DRC compression.

<center><img src="images/Pre-defined DRC Compression Scheme.png" style="width:100%; height:auto;"></center>
<center><figcaption>Pre-defined DRC Compression Scheme</figcaption></center>

The below is the equation that represents the compressor scheme of Figure 17.

```
	Y = D_T(i) + (X - T(i)) / R(i). Where,
	X ∈ Seg(i) and D_T (i) = T(0) + ∑ ((T(k+1) - T(k)) / R(k)) (k = 0 to i-1).
	Seg(i): ith Segment
	 T(i) : Threshold vlaue in dBFS for Seg(i), where T(0) = -96.33
	 R(i) : Ratio value for Seg(i)
	D_T(i): Threshold value in dBFS for Seg(i) after DRC compression, where D_T(0) = T(0)
	  X   : Input sample value in dBFS
	  Y   : Output sample value in dBFS
```

#### Limiter #### {#iadecoding-iadecoder-channelaudio-limiter}

This module limits the true peak of input signal at -1dB. The definition of thr true peak is base on [[!ITU1770-4]].

Below is a recommended loudness normalization and DRC control principle according to application.
- For AV application, it only applies Limiter at -1dBTP.
- For TV application, it only applies Loudness normalization at -24LKFS and Limiter at -1dBTP.
- For Mobile application, it applies Loudness normalization at -24LKFS, the pre-defined DRC control and adjusting of target loudness at -16 LKFS, and Limiter at -1dBTP.

NOTE: The definitions of AV, TV and Mobile applications are as follows:
.AV application: Sound devices with external speakers such as Soundbar, AV receiver, HiFi speaker etc..
.TV application: Television with built-in speakers such as LCD/OLED slim TV.
.Mobile application: Handheld devices with built-in speakers such as smartphone, tablet etc..

### IA Decoder for Ambisonics and Channel Audio decoding ### {#iadecoding-iadecoder-ambisonics-channelaudio}

Ambisonics and Channel Audio decoding is a simple parallel processing of both Ambisoncis decoding and Channel Audio decoding which are described in [[#iadecoding-iadecoder-ambisonics]] and [[#iadecoding-iadecoder-channelaudio]], respectively.

## Down-mix Matrix (Static) ## {#iadecoding-downmixmatrix}

This section provides static down-mix matrices.

IAC players need to support any valid channel layout, even if the number of channels does not match the physically connected audio hardware. Players need to perform channel mixing to increase or reduce the number of channels as needed.

Implementations can use the matrices below to implement down-mixing from the output channel audio, which are known to give acceptable results for stereo, 5.1ch, 7.1ch and 3.1.2ch.

Down-mixing can be done directly by using one of the matrices below or a combination of them. For example, stereo down-mixing for 7.1.4ch can be done by the combination of the 7.1ch down-mix matrix for 7.1.4ch, 5.1ch down-mix matrix for 7.1ch and stereo down-mix matrix for 5.1ch.

The figures below show static down-mix matrices to stereo, 5.1ch and 7.1ch.

<center><img src="images/7.1ch Down-mix Matrix for 7.1.4ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>7.1ch Down-mix matrix for 7.1.4ch</figcaption></center>

<center><img src="images/7.1ch Down-mix Matrix for 7.1.2ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>7.1ch Down-mix matrix for 7.1.2ch</figcaption></center>

<center><img src="images/5.1ch Down-mix Matrix for 5.1.4ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>5.1ch Down-mix matrix for 5.1.4ch</figcaption></center>

<center><img src="images/5.1ch Down-mix Matrix for 5.1.2ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>5.1ch Down-mix matrix for 5.1.2ch</figcaption></center>

<center><img src="images/5.1ch Down-mix Matrix for 7.1ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>5.1ch Down-mix matrix for 7.1ch</figcaption></center>

<center><img src="images/Stereo Down-mix Matrix for 5.1ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>Stereo Down-mix matrix for 5.1ch</figcaption></center>

<center><img src="images/Stereo Down-mix Matrix for 3.1.2ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>Stereo Down-mix matrix for 3.1.2ch</figcaption></center>

The figures below show static down-mix matrices to 3.1.2ch.

<center><img src="images/3.1.2ch Down-mix Matrix for 5.1.2ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>3.1.2ch Down-mix matrix for 5.1.2ch</figcaption></center>

<center><img src="images/3.1.2ch Down-mix Matrix for 5.1.4ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>3.1.2ch Down-mix matrix for 5.1.4ch</figcaption></center>

<center><img src="images/3.1.2ch Down-mix Matrix for 7.1.2ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>3.1.2ch Down-mix matrix for 7.1.2ch</figcaption></center>

<center><img src="images/3.1.2ch Down-mix Matrix for 7.1.4ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>3.1.2ch Down-mix matrix for 7.1.4ch</figcaption></center>

Where, p1 = 0.707 and p2 = 0.3535. Implementations may use limiter defined in [[#iadecoding-iadecoder-channelaudio-limiter]] to preserve energy of audio signals instead of normalization factors.

## Down-mix Matrix (Static) (Informative) ## {#iaencoding-downmixmatrix}

IAC encoders can do down-mixing from channel-based input audio by using down-mixing mechanism which is specified in [[#iaencoding-iaencoder-channelaudio-downmixmechanism]] or the matrices in this section.

This section provides static down-mix matrices for stereo, 5.1ch and 7.1ch.

It is RECOMMENDED to use the matrices below to implement down-mixing from a channel-based input audio.

Down-mixing can be done directly by using one of the matrices below or can be done by using a combination of the matrices below. For example, stereo down-mixing from 7.1.4ch can be done by the combination of 7.1ch down-mix matrix for 7.1.4ch, 5.1ch down-mix matrix for 7.1ch and stereo down-mix matrix for 5.1ch.

Below figures show static down-mix matrices to stereo, 5.1ch and 7.1ch.

<center><img src="images/7.1ch Down-mix Matrix for 7.1.4ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>7.1ch Down-mix matrix for 7.1.4ch</figcaption></center>

<center><img src="images/7.1ch Down-mix Matrix for 7.1.2ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>7.1ch Down-mix matrix for 7.1.2ch</figcaption></center>

<center><img src="images/5.1ch Down-mix Matrix for 5.1.4ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>5.1ch Down-mix matrix for 5.1.4ch</figcaption></center>

<center><img src="images/5.1ch Down-mix Matrix for 5.1.2ch.png" style="width:100%; height:auto;"></center>
<center><figcaption>5.1ch Down-mix matrix for 5.1.2ch</figcaption></center>

<center><img src="images/5.1ch Down-mix Matrix for 7.1ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>5.1ch Down-mix matrix for 7.1ch</figcaption></center>

<center><img src="images/Stereo Down-mix Matrix for 5.1ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>Stereo Down-mix matrix for 5.1ch</figcaption></center>

<center><img src="images/Stereo Down-mix Matrix for 3.1.2ch.png" style="width:80%; height:auto;"></center>
<center><figcaption>Stereo Down-mix matrix for 3.1.2ch</figcaption></center>


# IAC Generation Process # {#iac-generation}

ISSUE: Copy-pasted from old version (Encoding Process Section). TODO: update.

This section provides a guideline for IA encoding for a given input audio format.

## Input Audio Format ## {#iaencoding-inputaudioformat}

Recommended input audio format for IA encoding is as follows:
- Ambiosnics format: It shall conform to [=ChannelMappingFamily=] = 2 or 3 of [[RFC8486]].
- Channel Audio format: It shall conform to[=loudspeaker_layout=] specified in channel_audio_layer_config().
- Ambisonics + Channel Audio format: In this case, Channel Audio is regarded as Non-diegetic.
- Input Smapling Rate: 48000hz
- Bitdepth: 16 bits or 24 bits
	- 16 bits are recommended for IAC-OPUS.
- Input file format: .wav file (Linear PCM, simply called as PCM)

## IA Encoder ## {#iaencoding-iaencoder}

For a given input audio and user inputs, IA encoder shall output [=IA bitstream=] which conform to [[#iabitstream-definition]].

Input audio shall be one of followings:
- Ambisonics format
- Channel Audio format
- Ambisonics + Channel Audio format

User inputs are:
- Ambisonics mode to indicate if [=ChannelMappingFamily=] = 2 or 3 of [[RFC8486]].
- List of channel layouts to be supported for scalable channel audio: it shall conform to [=loudspeaker_layout=].

IA encoder is composed of Pre-processor, Codec encoder and OBU packetizer as depicted in below figure.
- Pre-processor outputs one or more ChannelGroups, IA_Static_Meta and Timed Metadata if needed based on the input audio and user inputs.
	- It outputs one single ChannelGroup for Ambisonics.
	- It outputs one or more ChannelGroups for Channel audio.
- Codec encoder generates one or more Substreams from each ChannelGroup and outputs the Substream(s) with one single Decoder_Config().
	- Mono or stereo coding is only allowed.
		- Ambisonics format: each channel is coded as mono mode
		- Channel Audio format: each pair of coupled channels in the same ChannelGroup is coded as stereo mode to generate one single Substream and each of non-coupled channels in the same ChannelGroup is coded as mono mode to generate one single Substream.
			- <dfn noexport>Coupled channels</dfn>: L/R, Ls/Rs, Lss/Rss, Lrs/Rrs, Ltf/Rtf, Ltb/Rtb
			- <dnf noexport>Non-coupled channels</dfn>: C, LFE, L
- OBU packetizer generates Non-timed Metadata and Temporal Unit for each frame, and outputs IA bitstream.
	- Non-timed Metadata generator generates OBUs for Codec_Specific_Info and IA_Static_Meta.
	- Temporal Unit generator generates Temporal Unit for each frame from Timed Metadata if present and Substreams.

<center><img src="images/IA Encoder Configuration.png" style="width:100%; height:auto;"></center>
<center><figcaption>IA Encoder Configuration</figcaption></center>

The order of Substreams in each ChannelGroup shall be as follows:
- In ChannelGroup for Ambisonics: The order shall conform to [[RFC8486]].
- In ChannelGroup for Channel audio: The order shall conform to following rules:
	- Coupled Substreams comes first and followed by non-coupled Substreams.
	- Coupled Substreams for surround channels comes first and followed by one(s) for top channels.
	- Coupled Substreams for front channels comes first and followed by one(s) for side, rear and back channels.
	- Coupled Substreams for side channels comes first and followed by one(s) for rear channels.
	- Center channel comes first and followed by LFE and followed by the other one.

Where, <dfn noexport>non-coupled Substream</dfn> is a coded Substream from one of non-coupled channels.

### IA Encoder for Ambisonics format ### {#iaencoding-iaencoder-ambisonics}

For Ambisonics format:
- Pre-processor outputs one ChannelGroup and IA_Static_Meta and it is only composed of Meta Generator.
	- Meta generator generates IA_Static_Meta based on Ambisonics mode and the number of channels for Ambisonics.
		- Ambisonics_Mode shall be set to 1 for [=ChannelMappingFamily=] = 2 of [[RFC8486]] or 2 for [=ChannelMappingFamily=] = 3 of [[RFC8486]].
		- Channel_Audio_Layer shall be set to 0.
		- Ambisonics Layer Config() is set to as follows:
			- [=output_channel_count=], [=substream_count=] and [=coupled_substream_count=] shall be set to the number of channels for Ambisonics.
			- [=channel_mapping=] for Ambisonics_Mode = 1 or [=demixing_matrix=] for Ambisonics_Mode = 2 is assigned to according to the order of Substreams in ChannelGroup.
- Codec Enc. outputs Substreams as many as the number of channels for Ambisoncis by coding each channel in a mono mode.
- Temporal Unit shall be composed of Temporal_Delimiter_OBU and followded by OBUs for Substreams.
	- The order of Substreams in ChanngelGroup shall be aligned with [=channel_mapping=] for Ambisonics_Mode = 1 or [=demixing_matrix=] for Ambisonics_Mode = 2.

### IA Encoder for Channel Audio format ### {#iaencoding-iaencoder-channelaudio}

For Channel Audio format:
- Pre-processor outputs one or more ChannelGroups, IA_Static_Meta and Timed Metadata. It is composed of Down-mix parameter generator, Down-mixer, Loudness, ChannelGroup generator, Attenation and Meta generator.
	- For non-scalable channel audio (i.e. Channel_Audio_Layer = 1):
		- Timed Metadata may not need to be generated. But Demixing_Info of Timed Metadata may be generated by implementers who assume it to be used for dynamic downmixing in a decoder side.

		- Down-mix parameter generator, Down-mixer, ChannelGroup generator and Attenuation modules are not needed.
	- Down-mix parameter generator generates 5 down-mix parameters (α(k), β(k), γ(k), δ(k) and w(k)) by analyzing input Channel Audio
	- Down-mixer generates down-mixed audios according to the list of channel layouts and the down-mix parameters.
	- Loudness module outputs the loudness level ([=LKFS=]) of each down-mixed audio based on [[ITU1770-4]].
	- ChannelGroup generator transforms the input Channel Audio to ChannelGroups for audio scalability by using transformation matrix.
		- Transformation matrix is generated based on down-mix parameters and the list of channel layouts.
	- Attenuation module applies a gain to prevent clipping of mixed channels.
	- Meta generator generates IA_Static_Meta, and Timed Metadata for each frame.
		- IA_Static_Meta shall be set to as follows:
			- Ambisonics_Mode shall be set to 0.
			- Channel_Audio_Layer shall be set to the number of channel layouts.
			- Channel_Audio Layer Config() shall be set to as follows:
				- [=loudspeaker_layout=] is set to the ith list of channel layouts for the ith ChannelGroup.
				- [=output_gain_is_present_flag=] is set to 1 for the ith ChannelGroup if attenuation is applied to the mixed channels of the ith ChannelGroup. Otherwise it is set to 0 for the ith ChannelGroup.
				- [=recon_gain_is_present_flag=] is set to 1 for the ith ChannelGroup if the preceding ChannelGroups has one or more mixed channels from the down-mixed audio for the ith channel layout. Otherwise, it is set to 0 for the ith ChannelGroup. Especially, when Channel_Audio_Layer = 1, this flag shall be set to 0.
				- [=substream_count=] is set to the nubmer of Substreams composing of the ith ChannelGroup.
				- [=coupled_substream_count=] is set to the nubmer of coupled Substreams among the Substreams composing of the ith ChannelGroup.
				- [=loudness=] is set to the loudness ([=LKFS=]) of the down-mixed audio for the ith channel layout for the ith ChannelGroup.
				- Each bit of [=output_gain_flags=] is set to 1 for the ith ChannelGroup if attenuation is applied to the relevant channel of the ith ChannelGroup. Otherwies it is set to 0 for the ith ChannelGroup.
				- [=output_gain=] is set to the inverse number of the gain which is applied to the channels which are indicated by output_gain_flags.
		- Timed Metadata can be composed of [=Demixing_Info()=] and [=Recon_Gain_Info()=]. When [=recon_gain_is_present_flag=] = 0 for all ChannelGroup, Recon_Gain_Info shall not present in IA bitstream.
			- [=dmixp_mode=] of Demixing_Info for the kth frame shall be set to indicate (α(k), β(k), γ(k), δ(k)) and w_idx_offset(k). Where w_idx_offset(k) = 1 or -1.
			- [=recon_gain_flags=] of Recon_Gain_Info shall be set to indicate the de-mixed channels, which need to apply [=recon_gain=] among the output channels after demixing for ith channel layout.
			- [=recon_gain=] shall be set to the gain value to be applied to the channel which is indicated by recon_gain_flags for the ith ChannelGroup.
- Temporal Unit shall be composed of Temporal_Delimiter_OBU, followed by OBUs for Timed Metadata and followed by OBUs for Substreams.
	- ChannelGroups in Temporal Unit shall be placed in order. In other words, ChannelGroup for the first channel layout shall come first, followed by ChannelGroup for the second channel layout, followed by ChannelGroup for the third channel layout and so on.

Below figure shows IA encoding flowchart for Channel Audio Format.
- For a given Channel Audio and a given list of channel layouts for scalability, PCMs for Channel Audio are passed to CG Generation moddule.
- CG Generation module generates the transformed audio according to CG generation rule based on the list of CLs and the down-mix parameters.
	- The transformed audio is structured as ChannelGroups.
- Non-mixed channels of the transformed audio (i.e., the original channels of the input channel audio) are directly input to Codec encoder, but the mixed channels may be input first to Attenuation module and then to Codec encoder.
- The Attenuation module reduces all sample values of the mixed channels in the same CG at a uniform rate (Output_Gain).
	- A range of 0dB to -6dB is recommended for the attenuation. (i.e. a range of 0dB to 6dB for Output_Gain)
- Codec Enc. generates the coded Substreams from PCMs and passes Substreams and one single Decoder_Config to OBU Packetizer.
- OBU packetizer generates Non-timed Metadata which consists of OBU for Codec_Specific_Info and OBU for IA_Static_Meta.
	- Codec_Specific_Info_OBU is generated based on [=Decoder_Config()=].
	- IA_Static_Meta_OBU is generated based on Ambix_Layer_Config and Channel_Audio_Layer_Config.
- OBU packetizer generates Temporal Unit for each frame.
	- OBU Packetizer generates Timed Metadata, which consists of OBU for Demixing_Info and OBU for Recon_Gain_Info, for each frame.
	- OBU Packetizer generates OBUs for Substreams for each frame.
- OBU Packetizer outputs IA Bitstream which is composed of OBUs for Non-timed Metadata and followed by OBUs for Temporal Units.

<center><img src="images/IA Encoding Flowchart for Channel Audio Format.png" style="width:100%; height:auto;"></center>
<center><figcaption>IA Encoding Flowchart for Channel Audio Format</figcaption></center>

Following sections, [[#iaencoding-iaencoder-channelaudio-downmixparameter]], [[#iaencoding-iaencoder-channelaudio-downmixmechanism]], [[#iaencoding-iaencoder-channelaudio-channellayoutgenerationrule]], [[#iaencoding-iaencoder-channelaudio-recongaingeneration]] and [[#iaencoding-iaencoder-channelaudio-channelgroupgenerationrule]] are not needed for non-scalable channel audio (i.e., when Channel_Audio_Layer of IA_Static_Meta is set to 1).

#### Down-mix parameter and Loudness #### {#iaencoding-iaencoder-channelaudio-downmixparameter}

This section describes how to generate down-mix parameters and loudness level for a given channel audio and a given list of channel layouts for scalability.

Below figure shows a block diagram for down-mix parameter and loudness module including down-mixer.

<center><img src="images/Down-mix Parameter and Loudness.png" style="width:100%; height:auto;"></center>
<center><figcaption>IA Down-mix Parameter and Loudness</figcaption></center>

For a given Channel Audio (e.g. 7.1.4ch) and a given list of channel layouts based on the Channel Audio,
- Down-mix parameter generator shall generate 5 down-mix parameters (α(k), β(k), γ(k), δ(k) and w(k)) by analyzing input Channel Audio, by refering [[AI-CAD-Mixing]]. Where, k is a frame index.
	- It is composed of Audio Scene Classification module and Height Energy Quantification module as depicted in Figure 11-2.
	- Audio Scene Classification module generates 4 parameters (α(k), β(k), γ(k), δ(k)) by classifying audio scenes of input channel audio in three modes.
		- Default scene: Neither Dialog nor Effect
		- Dialog scene: Center-channel oriented and clear dialog/voice sounds
		- Effect scene: Directional and spatially moving sounds.
	- Height Energy Quantification module generates a surround to height mixing parameter (w(k)) which is decided according to the relative energy difference between the top and surround channels of input channel audio.
		- If the energy of top channels is bigger than that of surround ones, then w_idx_offset(k) is set to 1. Otherwise, it is set to -1. And, w(k) is calculated based on w_idx_offset(k) and conforms to [[#iadecoding-iadecoder]].
- Down-mixer generates down-mixed audios from input Channel Audio according to the list of channel layouts and the down-mix parameters, and outputs down-mixed audio for each channel layout to Loudness module.
	- It is not depicted in the figure but Down-mixer further generates [=Dmixp_Mode=] and [=Recon_Gains=] for each frame to be passed to OBU packetizer.
- Loudness module measures the loudness level ([=LKFS=]) of each down-mixed audio based on [[ITU1770-4]], and passes them to OBU packetizer.

#### Down-mix Mechanism #### {#iaencoding-iaencoder-channelaudio-downmixmechanism}

This section specifies the down-mixing mechanism to generate <dfn noexport>down-mixed audio</dfn> for scalable channel audio.

For a given Channel Audio which conforms to [[=loudspeaker_layout]], the surround and top channels (if any) are separately down-mixed and especially step by step until to get a target channels.

Implementors may use another method to get the down-mixed audio from the given channel audio, but the down-mixed audio shall comply with that by this section.

Therefore, a down-mixer based on the down-mix mechanisam is a combination of following surround down-mixer(s) and top down-mixer(s) as depicted in below figure.
- Surround Down-mixers: S7to5 enc., S5to3 enc., S3to2 enc., S2to1 enc.

```
	S7to5 enc.: Ls5 = α(k) x Lss7 + β(k) x Lrs7 and Rs5 = α(k) x Rss7 + β(k) x Rrs7.
	S5to3 enc.: L3 = L5 + δ(k) x Ls5 and R3 = R5 + δ(k) x Rs5
	S3to2 enc.: L2 = L3 + 0.707 x C and R2 = R3 + 0.707 x C
	S2to1 enc.: Mono = 0.5 x (L2 + R2)
```

- Top Down-mixers: T4to2 enc., T2toTF2 enc.

```
	T4to2 enc.: Ltf2 = Ltf4 + γ(k) x Ltb4  and Rtf2 = Rtf4 + γ(k) x Rtb4.
	T2toTF2 enc.: Ltf3 = Ltf2 + w(k) x δ(k) x Ls5 and Rtf3 = Rtf2 + w(k) x δ(k) x Rs5.
```

<center><img src="images/Down-mix Mechanism.png" style="width:100%; height:auto;"></center>
<center><figcaption>IA Down-mix Mechanism</figcaption></center>

```
For example, to get down-mixed 3.1.2ch from 7.1.4ch:
- S3 of 3.1.2ch is generated by using S7to5 and S5to3 encs.
- TF2 of 3.1.2ch is generated by using T4to2 and T2toTF2 encs.
```

#### Channel Layout Generation Rule #### {#iaencoding-iaencoder-channelaudio-channellayoutgenerationrule}

This section describes the generation rule for channel layouts for scalable channel audio.

For a given channel layout (CL #n) of input Channel Audio, any list of CLs ({CL #i: i = 1, 2, ..., n}) for a scalable channel audio shall comform with following rules:
- Si ≤ Si+1 and Wi ≤ Wi+1 and Ti ≤ Ti+1 except Si = Si+1 and Wi = Wi+1 and Ti = Ti+1 for i = n-1, n-2, …, 1. Where ith Channel Layout CL #i = Si.Wi.Ti.
- CL #i is one of [=loudspeaker_layouts=] supported in this specification.

Down-mix paths, which conform to the above rule, shall be only allowed for scalable channel audio with [=num_layers=] > 1 as depicted in below figure.

<center><img src="images/Down-mix Path.png" style="width:100%; height:auto;"></center>
<center><figcaption>IA Down-mix Path</figcaption></center>

#### Recon Gain Generation #### {#iaencoding-iaencoder-channelaudio-recongaingeneration}

This section describes how to generate [=Recon_Gain=].

Recon_Gain needs to be applied to de-mixed channels. For this, IA encoder needs to deliver it to IA decoders.

Let's define followings:
- Level Ok is the signal power for the frame #k of a channel of the down-mixed audio for CL #i.
- Level Mk is the signal power for the frame #k of the relevant mixed channel of the down-mixed audio for CL #i-1.
- Level Dk is the signal power for the frame #k of the de-mixed channel for CL #i (after demixing).

If 10*log10(level Ok / maxL^2) is less than the first threshold value (e.g. -80dB), Recon_Gain (k, i)  = 0. Where, maxL = 32767 for 16bits.

If 10*log10(level Ok / level Mk ) is less than the second threshold value (e.g. -6dB), Recon_Gain (k, i) is set to the value which makes level Ok = Recon_Gain (k, i)^2 x level Dk. Otherwise, Recon_Gain (k, i) = 1. Actual value to be delivered is floor(255*Recon_Gain).

```
For example, if we assume CL #i = 7.1.4ch and CL #i-1 = 5.1.2ch, then de-mixed channels are D_Lrs7, D_Rrs7, D_Ltb4 and D_Rtb4.
- D_Lrs7 and D_Rrs7 are de-mixed from Ls5 and Rs5 in the (i-1)th ChanngelGroup by using Lss7 and Rss7 in the ith ChannelGroup and its relevant demixing parameters (i.e., α(k) and β(k)) , respectively.
- D_Ltb4 and D_Rtb4 are de-mixed from Ltf2 and Rtf2 in the (i-1)th ChanngelGroup by using Ltf4 and Rtf4 in the ith ChannelGroup and its relevant demixing parameter (i.e., γ(k)), respectively.

Recon_Gain for D_Lrs7:
- Level Ok is the signal power for the frame #k of Lrs7 in the ith ChanngGroup.
- Level Mk is the signal power for the frame #k of Ls5 in the (i-1)th ChannelGroup.
- Level Dk is the signal power for the frame #k of D_Lrs7.
Recon_Gain for D_Rrs7:
- Level Ok is the signal power for the frame #k of Rrs7 in the ith ChanngGroup.
- Level Mk is the signal power for the frame #k of Rs5 in the (i-1)th ChannelGroup.
- Level Dk is the signal power for the frame #k of D_Rrs7.
Recon_Gain for D_Ltb4:
- Level Ok is the signal power for the frame #k of Ltf4 in the ith ChanngGroup.
- Level Mk is the signal power for the frame #k of Ltf2 in the (i-1)th ChannelGroup.
- Level Dk is the signal power for the frame #k of D_Ltb4.
Recon_Gain for D_Rtb4:
- Level Ok is the signal power for the frame #k of Rtf4 in the ith ChanngGroup.
- Level Mk is the signal power for the frame #k of Rtf2 in the (i-1)th ChannelGroup.
- Level Dk is the signal power for the frame #k of D_Rtb4.
```

#### ChannelGroup Generation Rule #### {#iaencoding-iaencoder-channelaudio-channelgroupgenerationrule}

This section describes the generation rule for ChannelGroup.

For a given Channel Audio and the list of CLs ({CL #i: i = 1, 2, ..., n}), CG Generation module outputs the transformed audio (i.e. ChannelGroups) which shall conform to following rules:
- It consists of C number of channels and is structured to n number of CGs, where C is the number of channels for the Channel Audio.
- CG #1 (as called BCG): This CG is the down-mixed audio itself for CL #1 generated from the Channel Audio. It contains C1 number of channels.
- CG #i (as called DCG, i = 2, 3, …, n): This CG contains (Ci – Ci-1) number of channels. (Ci – Ci-1) channel(s) consists of as follows:
	- (Si – Si-1) surround channel(s) if Si > Si-1 . When S_set = { x | Si-1 < x ≤ Si and x is an integer},
		- If 2 is an element of S_set, the L2 channel is contained in this CG #i.
		- If 3 is an element of S_set, the Center channel is contained in this CG #i.
		- If 5 is an element of S_set, the L5 and R5 channels are contained in this CG #i.
		- If 7 is an element of S_set, the Lss7 and Rss7 channels are contained in this CG #i.
	- The LFE channel if Wi > Wi-1 .
	- (Ti – Ti-1) top channels if Ti > Ti-1 .
		- If Ti-1 = 0, the top channels of the down-mixed audio for CL #i are contained in this CG #i.
		- If Ti-1 = 2, the Ltf and Rtf channels of the down-mixed audio for CL #i are contained in this CG #i.

Below figure shows one example of transformation matrix with 4 CGs (2ch/3.1.2ch/5.1.2ch/7.1.4ch).

<center><img src="images/Example of Transformation Matrix with 4 CGs.png" style="width:100%; height:auto;"></center>
<center><figcaption>Example of Transformation Matrix with 4 CGs</figcaption></center>

### IA Encoder for Ambisonics and Channel Audio format ### {#iaencoding-iaencoder-ambisoncis-channelaudio}

For Ambisonics and Channel Audio format:
- One single ChannelGroup for Ambisonics is generated in the same way with [[#iaencoding-iaencoder-ambisonics]].
- One or more ChannelGroups and Timed Metadata for Channel Audio are generated in the same way with [[#iaencoding-iaencoder-ambisonics]].
- IA_Static_Meta shall be set to as follows:
	- Ambisonics_Mode shall be set to according to Ambisonics mode in the same way with [[#iaencoding-iaencoder-ambisonics]].
	- Channel_Audio_Layer shall be set in the same way with [[#iaencoding-iaencoder-channelaudio]].
	- ambix_layer_config shall be set in the same way with [[#iaencoding-iaencoder-ambisonics]].
	- channel_audio_layer_config shall be set in the same way with [[#iaencoding-iaencoder-channelaudio]].
- Temporal Unit is composed of Temporal_Delimiter_OBU, followed by OBUs for Timed Metadata if present and followed by OBUs for Substreams.
	- OBUs for Substreams composing of ChannelGroup for Ambisonics shall come first and followed by OBUs for Substreams composing of ChannelGroups for Channel Audio.

Below figure shows IA encoding flowchart for Ambisonics and Channel Audio format with non-scalable channel audio.

<center><img src="images/IA Encoding Flowchart for Ambisonics and Channel Audio Format.png" style="width:100%; height:auto;"></center>
<center><figcaption>IA Encoding Flowchart for Ambisonics and Channel Audio Format</figcaption></center>


# Consumption of IAC bitstream # {#iac-consumption}

ISSUE: TODO. Fill in example workflows.

ISSUE: below is copy-pasted from the old version (IAC Decapsulation Process). TODO: update it.

## IAC Decapsulation Process ## {#iacdecapsulation}

This section provides a guideline for IAC parser to reconstruct IA bitstreams (i.e., IA sequence) from IAC file.

When IAC parser feeds the reconstructed IA bitstreams to IAC-OBU parser, IA_Stream_Indicator_OBU shall be placed at the front of the first IA bistream to let IAC-OBU parser know OBUs for IA bistreams are coming.

Below figure shows the mirroring process of the encapsulation scheme of IA bitstream specified in [[#isobmff]].

<center><img src="images/IAC Decapsulation Guideline.png" style="width:100%; height:auto;"></center>
<center><figcaption>IAC Decapsulation Guideline</figcaption></center>

During decapsulation process, IAC file is decapsulated into IA bitstreams which shall conform to [[#iabitstream-definition]] as follows:
- Step1: Reconstruction of global descriptor for the ith IA bitstream
	- [Step1-1] global descriptor: take the ith SampleGroupDescriptionEntry as it is in SampleGroup with grouping_type, [=iagd=].
	- [Step1-2] Figure out the offset (i1) and number (im) of Samples, which the ith SampleGroupDescriptionEntry is applied to, from the SampleGroup.
- Step2: Reconstructing of the jth access unit of the ith IA Bitstream (j = i1, i2, …, im)
	- [Step2-1] take jth sample data without gap to reconstruct the jth access unit.
- Step3: Place global descriptor and followed by access units in order (j = i1, i2, …, im) without gap to reconstruct the ith IA bitstream.
